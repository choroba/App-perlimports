#!perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"PPI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI';
  package PPI;use 5.006;use strict;our$VERSION='1.271';our ($XS_COMPATIBLE,@XS_EXCLUDE)=('0.845');use PPI::Util ();use PPI::Exception ();use PPI::Element ();use PPI::Token ();use PPI::Statement ();use PPI::Structure ();use PPI::Document ();use PPI::Document::File ();use PPI::Document::Fragment ();use PPI::Document::Normalized ();use PPI::Normal ();use PPI::Tokenizer ();use PPI::Lexer ();die if!$PPI::XS_DISABLE and!eval {require PPI::XS;1}and $@ !~ /^Can't locate .*? at /;1;
PPI

$fatpacked{"PPI/Cache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_CACHE';
  package PPI::Cache;use strict;use Carp ();use File::Spec ();use File::Path ();use Storable 2.17 ();use Digest::MD5 2.35 ();use Params::Util qw{_INSTANCE _SCALAR};use PPI::Document ();our$VERSION='1.271';use constant VMS=>!!($^O eq 'VMS');sub import {my$class=ref $_[0]? ref shift : shift;return 1 unless @_;my$cache=$class->new(@_);unless (PPI::Document->set_cache($cache)){Carp::croak("Failed to set cache in PPI::Document")}1}sub new {my$class=shift;my%params=@_;my$path=$params{path}or Carp::croak("Cannot create PPI::Cache, no path provided");unless (-d $path){Carp::croak("Cannot create PPI::Cache, path does not exist")}unless (-r $path and -x $path){Carp::croak("Cannot create PPI::Cache, no read permissions for path")}if (!$params{readonly}and!-w $path){Carp::croak("Cannot create PPI::Cache, no write permissions for path")}my$self=bless {path=>$path,readonly=>!!$params{readonly},},$class;$self}sub path {$_[0]->{path}}sub readonly {$_[0]->{readonly}}sub get_document {my$self=ref $_[0]? shift : Carp::croak('PPI::Cache::get_document called as static method');my$md5hex=$self->_md5hex(shift)or return undef;$self->_load($md5hex)}sub store_document {my$self=shift;my$Document=_INSTANCE(shift,'PPI::Document')or return undef;return 1 if$self->readonly;my$md5hex=$Document->hex_id or return undef;$self->_store($md5hex,$Document)}sub _store {my ($self,$md5hex,$object)=@_;my ($dir,$file)=$self->_paths($md5hex);File::Path::mkpath($dir,0,0755)unless -d $dir;if (VMS){Storable::lock_nstore($object,$file)}else {Storable::nstore($object,$file)}}sub _load {my ($self,$md5hex)=@_;my (undef,$file)=$self->_paths($md5hex);return '' unless -f $file;my$object=VMS ? Storable::retrieve($file): Storable::lock_retrieve($file);unless (_INSTANCE($object,'PPI::Document')){Carp::croak("Security Violation: Object in '$file' is not a PPI::Document")}$object}sub _paths {my$self=shift;my$md5hex=lc shift;my$dir=File::Spec->catdir($self->path,substr($md5hex,0,1),substr($md5hex,0,2));my$file=File::Spec->catfile($dir,$md5hex .'.ppi');return ($dir,$file)}sub _md5hex {my$either=shift;my$it=_SCALAR($_[0])? PPI::Util::md5hex(${$_[0]}): $_[0];return (defined$it and!ref$it and $it =~ /^[[:xdigit:]]{32}\z/s)? lc$it : undef}1;
PPI_CACHE

$fatpacked{"PPI/Document.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT';
  package PPI::Document;use strict;use Carp ();use List::Util 1.33 ();use Params::Util 1.00 qw{_SCALAR0 _ARRAY0 _INSTANCE};use Digest::MD5 ();use PPI::Util ();use PPI ();use PPI::Node ();use overload 'bool'=>\&PPI::Util::TRUE;use overload '""'=>'content';our$VERSION='1.271';our ($errstr,@ISA)=("","PPI::Node");use PPI::Document::Fragment ();my$CACHE;use constant LOCATION_LINE=>0;use constant LOCATION_CHARACTER=>1;use constant LOCATION_COLUMN=>2;use constant LOCATION_LOGICAL_LINE=>3;use constant LOCATION_LOGICAL_FILE=>4;sub new {local $_;my$class=ref $_[0]? ref shift : shift;unless (@_){my$self=$class->SUPER::new;$self->{readonly}=!1;$self->{tab_width}=1;return$self}my$source=shift;my%attr=@_;if (!defined$source){$class->_error("An undefined value was passed to PPI::Document::new")}elsif (!ref$source){if ($source =~ /(?:\012|\015)/){Carp::croak("API CHANGE: Source code should only be passed to PPI::Document->new as a SCALAR reference")}$attr{filename}||= $source;if ($CACHE){my$file_contents=PPI::Util::_slurp($source);return$class->_error($file_contents)if!ref$file_contents;my$document=$CACHE->get_document($file_contents);return$class->_setattr($document,%attr)if$document;$document=PPI::Lexer->lex_source($$file_contents);if ($document){$CACHE->store_document($document);return$class->_setattr($document,%attr)}}else {my$document=PPI::Lexer->lex_file($source);return$class->_setattr($document,%attr)if$document}}elsif (_SCALAR0($source)){my$document=PPI::Lexer->lex_source($$source);return$class->_setattr($document,%attr)if$document}elsif (_ARRAY0($source)){$source=join '',map {"$_\n"}@$source;my$document=PPI::Lexer->lex_source($source);return$class->_setattr($document,%attr)if$document}else {$class->_error("Unknown object or reference was passed to PPI::Document::new")}my$errstr;if (_INSTANCE($@,'PPI::Exception')){$errstr=$@->message}elsif ($@){$errstr=$@;$errstr =~ s/\sat line\s.+$//}elsif (PPI::Lexer->errstr){$errstr=PPI::Lexer->errstr}else {$errstr="Unknown error parsing Perl document"}PPI::Lexer->_clear;$class->_error($errstr)}sub load {Carp::croak("API CHANGE: File names should now be passed to PPI::Document->new to load a file")}sub _setattr {my ($class,$document,%attr)=@_;$document->{readonly}=!!$attr{readonly};$document->{filename}=$attr{filename};return$document}sub set_cache {my$class=ref $_[0]? ref shift : shift;if (defined $_[0]){my$object=_INSTANCE(shift,'PPI::Cache')or return undef;$CACHE=$object}else {$CACHE=undef}1}sub get_cache {$CACHE}sub filename {$_[0]->{filename}}sub readonly {$_[0]->{readonly}}sub tab_width {my$self=shift;return$self->{tab_width}unless @_;$self->{tab_width}=shift}sub save {my$self=shift;local*FILE;open(FILE,'>',$_[0])or return undef;binmode FILE;print FILE$self->serialize or return undef;close FILE or return undef;return 1}sub serialize {my$self=shift;my@tokens=$self->tokens;my$heredoc='';my$output='';for my$i (0 .. $#tokens){my$Token=$tokens[$i];unless ($Token->isa('PPI::Token::HereDoc')){my$content=$Token->content;unless ($heredoc ne '' and $content =~ /\n/){$output .= $content;next}if ($content eq "\n"){$output .= $content .$heredoc}else {$content =~ s/\n/\n$heredoc/;$output .= $content}$heredoc='';next}$output .= $Token->content;my$indentation=$Token->indentation || '';for my$line ($Token->heredoc){$heredoc .= "\n" eq $line ? $line : $indentation .$line}if ($Token->{_damaged}){my$last_index=$#tokens;if ($tokens[$last_index]->{content}=~ /^[^\n]*\n$/){$last_index--}my$last_line=List::Util::none {$tokens[$_]and $tokens[$_]->{content}=~ /\n/}(($i + 1).. $last_index);if (!defined$last_line){$last_line=1}my$any_after=List::Util::any {$tokens[$_]->isa('PPI::Token::HereDoc')and (scalar(@{$tokens[$_]->{_heredoc}})or defined$tokens[$_]->{_terminator_line})}(($i + 1).. $#tokens);if (!defined$any_after){$any_after=''}unless ($last_line and!$any_after){unless (defined$Token->{_terminator_line}){$Token->{_terminator_line}=$Token->{_terminator}}unless ($Token->{_terminator_line}=~ /\n$/){$Token->{_terminator_line}.= "\n"}}}if (defined$Token->{_terminator_line}){$heredoc .= $indentation .$Token->{_terminator_line}}}if ($heredoc ne ''){unless ($output =~ /\n$/){$output .= "\n"}$output .= $heredoc}$output}sub hex_id {PPI::Util::md5hex($_[0]->serialize)}sub index_locations {my$self=shift;my@tokens=$self->tokens;my$heredoc=0;my ($first,$location)=();for (0 .. $#tokens){my$Token=$tokens[$_];next if$Token->{_location};if ($_){$location=$self->_add_location($location,$tokens[$_ - 1],\$heredoc)}else {my$logical_file=$self->can('filename')? $self->filename : undef;$location=[1,1,1,1,$logical_file ]}$first=$_;last}if (defined$first){for ($first .. $#tokens){my$Token=$tokens[$_];$Token->{_location}=$location;$location=$self->_add_location($location,$Token,\$heredoc);if ($Token->isa('PPI::Token::HereDoc')){$heredoc += $Token->heredoc + 1}}}1}sub _add_location {my ($self,$start,$Token,$heredoc)=@_;my$content=$Token->{content};my$newlines=()=$content =~ /\n/g;my ($logical_line,$logical_file)=$self->_logical_line_and_file($start,$Token,$newlines);unless ($newlines){return [$start->[LOCATION_LINE],$start->[LOCATION_CHARACTER]+ length($content),$start->[LOCATION_COLUMN]+ $self->_visual_length($content,$start->[LOCATION_COLUMN]),$logical_line,$logical_file,]}my$physical_line=$start->[LOCATION_LINE]+ $newlines;my$location=[$physical_line,1,1,$logical_line,$logical_file ];if ($heredoc and $$heredoc){$location->[LOCATION_LINE]+= $$heredoc;$location->[LOCATION_LOGICAL_LINE]+= $$heredoc;$$heredoc=0}if ($content =~ /\n([^\n]+?)\z/){$location->[LOCATION_CHARACTER]+= length($1);$location->[LOCATION_COLUMN]+= $self->_visual_length($1,$location->[LOCATION_COLUMN],)}$location}sub _logical_line_and_file {my ($self,$start,$Token,$newlines)=@_;if ($start->[LOCATION_CHARACTER]==1){if ($Token->isa('PPI::Token::Comment')){if ($Token->content =~ m<
  					\A
  					\#      \s*
  					line    \s+
  					(\d+)   \s*
  					(?: (\"?) ([^\"]* [^\s\"]) \2 )?
  					\s*
  					\z
  				>xms){return $1,($3 || $start->[LOCATION_LOGICAL_FILE])}}elsif ($Token->isa('PPI::Token::Pod')){my$content=$Token->content;my$line;my$file=$start->[LOCATION_LOGICAL_FILE];my$end_of_directive;while ($content =~ m<
  					^
  					\#      \s*?
  					line    \s+?
  					(\d+)   (?: (?! \n) \s)*
  					(?: (\"?) ([^\"]*? [^\s\"]) \2 )??
  					\s*?
  					$
  				>xmsg){($line,$file)=($1,($3 || $file));$end_of_directive=pos$content}if (defined$line){pos$content=$end_of_directive;my$post_directive_newlines=()=$content =~ m< \G [^\n]* \n >xmsg;return$line + $post_directive_newlines - 1,$file}}}return $start->[LOCATION_LOGICAL_LINE]+ $newlines,$start->[LOCATION_LOGICAL_FILE]}sub _visual_length {my ($self,$content,$pos)=@_;my$tab_width=$self->tab_width;my ($length,$vis_inc);return length$content if$content !~ /\t/;for my$part (split(/(\t)/,$content)){if ($part eq "\t"){$vis_inc=$tab_width - ($pos-1)% $tab_width}else {$vis_inc=length$part}$length += $vis_inc;$pos += $vis_inc}$length}sub flush_locations {shift->_flush_locations(@_)}sub normalized {PPI::Normal->process($_[0]->clone)}sub complete {my$self=shift;$self->find_any(sub {$_[1]->isa('PPI::Structure')and !$_[1]->complete})and return '';my@child=$self->children;while (@child and not $child[-1]->isa('PPI::Statement')){pop@child}return '' unless@child;return$child[-1]->_complete}sub scope() {1}sub insert_before {return undef}sub insert_after {return undef}sub replace {return undef}sub _error {$errstr=$_[1];undef}sub _clear {$errstr='';$_[0]}sub errstr {$errstr}sub STORABLE_freeze {my$self=shift;my$class=ref$self;my%hash=%$self;return ($class,\%hash)}sub STORABLE_thaw {my ($self,undef,$class,$hash)=@_;bless$self,$class;for (keys %$hash){$self->{$_}=delete$hash->{$_}}$self->__link_children}1;
PPI_DOCUMENT

$fatpacked{"PPI/Document/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_FILE';
  package PPI::Document::File;use strict;use Carp ();use Params::Util qw{_STRING _INSTANCE};use PPI::Document ();our$VERSION='1.271';our@ISA='PPI::Document';sub new {my$class=shift;my$filename=_STRING(shift);unless (defined$filename){return$class->_error("Did not provide a file name to load")}my$self=$class->SUPER::new($filename,@_)or return undef;if (_INSTANCE($self,'PPI::Document')){bless$self,'PPI::Document::File'}else {die "PPI::Document::File SUPER call returned an object of the wrong type"}$self}sub save {my$self=shift;my$filename=shift;unless (defined$filename){$filename=$self->filename}$self->SUPER::save($filename,@_)}1;
PPI_DOCUMENT_FILE

$fatpacked{"PPI/Document/Fragment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_FRAGMENT';
  package PPI::Document::Fragment;use strict;use PPI::Document ();our$VERSION='1.271';our@ISA='PPI::Document';sub index_locations {warn "Useless attempt to index the locations of a document fragment";undef}sub scope() {''}1;
PPI_DOCUMENT_FRAGMENT

$fatpacked{"PPI/Document/Normalized.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_NORMALIZED';
  package PPI::Document::Normalized;use strict;use Scalar::Util qw{refaddr reftype blessed};use Params::Util qw{_INSTANCE _ARRAY};use PPI::Util ();our$VERSION='1.271';use overload 'bool'=>\&PPI::Util::TRUE;use overload '=='=>'equal';sub new {my$class=shift;my%args=@_;my$Document=_INSTANCE($args{Document},'PPI::Document')or return undef;my$version=$args{version};my$functions=_ARRAY($args{functions})or return undef;my$self=bless {Document=>$Document,version=>$version,functions=>$functions,},$class;$self}sub _Document {$_[0]->{Document}}sub version {$_[0]->{version}}sub functions {$_[0]->{functions}}sub equal {my$self=shift;my$other=_INSTANCE(shift,'PPI::Document::Normalized')or return undef;return undef if$self->{processing};my$v1=$self->version || "undef";my$v2=$other->version || "undef";return '' if$v1 ne $v2;$self->_equal_ARRAY($self->functions,$other->functions)or return '';$self->{seen}={};my$rv=$self->_equal_blessed($self->_Document,$other->_Document);delete$self->{seen};$rv}sub _equal_blessed {my ($self,$this,$that)=@_;my ($bthis,$bthat)=(blessed$this,blessed$that);$bthis and $bthat and $bthis eq $bthat or return '';$self->_equal_reference($this,$that)}sub _equal_reference {my ($self,$this,$that)=@_;my ($rthis,$rthat)=(refaddr$this,refaddr$that);$rthis and $rthat or return undef;my$seen=$self->{seen}->{$rthis};if ($seen and $seen ne $rthat){return ''}my ($tthis,$tthat)=(reftype$this,reftype$that);$tthis and $tthat and $tthis eq $tthat or return undef;$self->{seen}->{$rthis}=$rthat;my$method="_equal_$tthat";my$rv=$self->$method($this,$that);delete$self->{seen}->{$rthis};$rv}sub _equal_SCALAR {my ($self,$this,$that)=@_;my ($cthis,$cthat)=($$this,$$that);return$self->_equal_blessed($cthis,$cthat)if blessed$cthis;return$self->_equal_reference($cthis,$cthat)if ref$cthis;return (defined$cthat and $cthis eq $cthat)if defined$cthis;!defined$cthat}sub _equal_REF {shift->_equal_SCALAR(@_)}sub _equal_ARRAY {my ($self,$this,$that)=@_;scalar(@$this)==scalar(@$that)or return '';for my$i (0 .. scalar(@$this)){my ($cthis,$cthat)=($this->[$i],$that->[$i]);if (blessed$cthis){return '' unless$self->_equal_blessed($cthis,$cthat)}elsif (ref$cthis){return '' unless$self->_equal_reference($cthis,$cthat)}elsif (defined$cthis){return '' unless (defined$cthat and $cthis eq $cthat)}else {return '' if defined$cthat}}1}sub _equal_HASH {my ($self,$this,$that)=@_;return '' unless scalar(keys %$this)==scalar(keys %$that);for my$k (keys %$this){return '' unless exists$that->{$k};my ($cthis,$cthat)=($this->{$k},$that->{$k});if (blessed$cthis){return '' unless$self->_equal_blessed($cthis,$cthat)}elsif (ref$cthis){return '' unless$self->_equal_reference($cthis,$cthat)}elsif (defined$cthis){return '' unless (defined$cthat and $cthis eq $cthat)}else {return '' if defined$cthat}}1}sub _equal_GLOB {my ($self,$this,$that)=@_;warn('GLOB comparisons are not supported');''}sub _equal_CODE {my ($self,$this,$that)=@_;refaddr$this==refaddr$that}sub _equal_IO {my ($self,$this,$that)=@_;warn('IO comparisons are not supported');''}sub DESTROY {if ($_[0]->{Document}){$_[0]->{Document}->DESTROY;delete $_[0]->{Document}}}1;
PPI_DOCUMENT_NORMALIZED

$fatpacked{"PPI/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DUMPER';
  package PPI::Dumper;use strict;use Params::Util qw{_INSTANCE};our$VERSION='1.271';sub new {my$class=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;my$self=bless {root=>$Element,display=>{memaddr=>'',indent=>2,class=>1,content=>1,whitespace=>1,comments=>1,locations=>0,},},$class;my@options=map {lc $_}@_;my%options=@options;for (keys %{$self->{display}}){if (exists$options{$_}){if ($_ eq 'indent'){$self->{display}->{indent}=$options{$_}}else {$self->{display}->{$_}=!!$options{$_}}}}$self->{indent_string}=join '',(' ' x $self->{display}->{indent});$self}sub print {CORE::print(shift->string)}sub string {my$array_ref=shift->_dump or return undef;join '',map {"$_\n"}@$array_ref}sub list {my$array_ref=shift->_dump or return ();@$array_ref}sub _dump {my$self=ref $_[0]? shift : shift->new(shift);my$Element=_INSTANCE($_[0],'PPI::Element')? shift : $self->{root};my$indent=shift || '';my$output=shift || [];my$show=1;if ($Element->isa('PPI::Token::Whitespace')){$show=0 unless$self->{display}->{whitespace}}elsif ($Element->isa('PPI::Token::Comment')){$show=0 unless$self->{display}->{comments}}push @$output,$self->_element_string($Element,$indent)if$show;if ($Element->isa('PPI::Node')){my$child_indent=$indent .$self->{indent_string};for my$child (@{$Element->{children}}){$self->_dump($child,$child_indent,$output)}}$output}sub _element_string {my$self=ref $_[0]? shift : shift->new(shift);my$Element=_INSTANCE($_[0],'PPI::Element')? shift : $self->{root};my$indent=shift || '';my$string='';if ($self->{display}->{memaddr}){$string .= $Element->refaddr .'  '}if ($self->{display}->{locations}){my$loc_string;if ($Element->isa('PPI::Token')){my$location=$Element->location;if ($location){$loc_string=sprintf("[ % 4d, % 3d, % 3d ] ",@$location)}}$string .= $loc_string || " " x 20}if ($self->{display}->{indent}){$string .= $indent}if ($self->{display}->{class}){$string .= ref$Element}if ($Element->isa('PPI::Token')){if ($self->{display}->{content}){my$content=$Element->content;$content =~ s/\n/\\n/g;$content =~ s/\t/\\t/g;$content =~ s/\f/\\f/g;$string .= "  \t'$content'"}}elsif ($Element->isa('PPI::Structure')){if ($self->{display}->{content}){my$start=$Element->start ? $Element->start->content : '???';my$finish=$Element->finish ? $Element->finish->content : '???';$string .= "  \t$start ... $finish"}}$string}1;
PPI_DUMPER

$fatpacked{"PPI/Element.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_ELEMENT';
  package PPI::Element;use strict;use Clone 0.30 ();use Scalar::Util qw{refaddr};use Params::Util qw{_INSTANCE _ARRAY};use List::Util ();use PPI::Util ();use PPI::Node ();use PPI::Singletons '%_PARENT';our$VERSION='1.271';our$errstr="";use overload 'bool'=>\&PPI::Util::TRUE;use overload '""'=>'content';use overload '=='=>'__equals';use overload '!='=>'__nequals';use overload 'eq'=>'__eq';use overload 'ne'=>'__ne';sub significant() {1}sub class {ref($_[0])}sub tokens {$_[0]}sub content() {''}sub parent {$_PARENT{refaddr $_[0]}}sub descendant_of {my$cursor=shift;my$parent=shift or return undef;while (refaddr$cursor!=refaddr$parent){$cursor=$_PARENT{refaddr$cursor}or return ''}return 1}sub ancestor_of {my$self=shift;my$cursor=shift or return undef;while (refaddr$cursor!=refaddr$self){$cursor=$_PARENT{refaddr$cursor}or return ''}return 1}sub statement {my$cursor=shift;while (!_INSTANCE($cursor,'PPI::Statement')){$cursor=$_PARENT{refaddr$cursor}or return ''}$cursor}sub top {my$cursor=shift;while (my$parent=$_PARENT{refaddr$cursor}){$cursor=$parent}$cursor}sub document {my$top=shift->top;_INSTANCE($top,'PPI::Document')and $top}sub next_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::Util::first {refaddr$elements->[$_]==$key}0..$#$elements;$elements->[$position + 1]|| ''}sub snext_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::Util::first {refaddr$elements->[$_]==$key}0..$#$elements;while (defined(my$it=$elements->[++$position])){return$it if$it->significant}''}sub previous_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::Util::first {refaddr$elements->[$_]==$key}0..$#$elements;$position and $elements->[$position - 1]or ''}sub sprevious_sibling {my$self=shift;my$parent=$_PARENT{refaddr$self}or return '';my$key=refaddr$self;my$elements=$parent->{children};my$position=List::Util::first {refaddr$elements->[$_]==$key}0..$#$elements;while ($position-- and defined(my$it=$elements->[$position])){return$it if$it->significant}''}sub first_token {my$cursor=shift;while ($cursor->isa('PPI::Node')){$cursor=$cursor->first_element or die "Found empty PPI::Node while getting first token"}$cursor}sub last_token {my$cursor=shift;while ($cursor->isa('PPI::Node')){$cursor=$cursor->last_element or die "Found empty PPI::Node while getting first token"}$cursor}sub next_token {my$cursor=shift;while (1){my$element=$cursor->next_sibling;if ($element){return$element if$element->isa('PPI::Token');return$element->first_token}$cursor=$cursor->parent or return '';if ($cursor->isa('PPI::Structure')and $cursor->finish){return$cursor->finish}}}sub previous_token {my$cursor=shift;while (1){my$element=$cursor->previous_sibling;if ($element){return$element if$element->isa('PPI::Token');return$element->last_token}$cursor=$cursor->parent or return '';if ($cursor->isa('PPI::Structure')and $cursor->start){return$cursor->start}}}sub clone {Clone::clone(shift)}sub __insert_before {my$self=shift;$self->parent->__insert_before_child($self,@_)}sub __insert_after {my$self=shift;$self->parent->__insert_after_child($self,@_)}sub remove {my$self=shift;my$parent=$self->parent or return$self;$parent->remove_child($self)}sub delete {$_[0]->remove or return undef;$_[0]->DESTROY;1}sub replace {my$self=ref $_[0]? shift : return undef;_INSTANCE(shift,ref$self)or return undef;die "The ->replace method has not yet been implemented"}sub location {my$self=shift;$self->_ensure_location_present or return undef;return [@{$self->{_location}}]}sub line_number {my$self=shift;my$location=$self->location()or return undef;return$location->[0]}sub column_number {my$self=shift;my$location=$self->location()or return undef;return$location->[1]}sub visual_column_number {my$self=shift;my$location=$self->location()or return undef;return$location->[2]}sub logical_line_number {my$self=shift;return$self->location()->[3]}sub logical_filename {my$self=shift;my$location=$self->location()or return undef;return$location->[4]}sub _ensure_location_present {my$self=shift;unless (exists$self->{_location}){my$Document=$self->document or return undef;if ($Document->isa('PPI::Document::Fragment')){return undef}$Document->index_locations or return undef;unless (exists$self->{_location}){return undef}}return 1}sub _flush_locations {my$self=shift;unless ($self==$self->top){return$self->top->_flush_locations($self)}my@Tokens=$self->tokens;if (_INSTANCE($_[0],'PPI::Element')){my$start=shift->first_token;while (my$Token=shift@Tokens){return 1 unless$Token->{_location};next unless refaddr($Token)==refaddr($start);delete $$Token->{_location};last}}for my$Token (@Tokens){delete$Token->{_location}}1}sub _xml_name {my$class=ref $_[0]|| $_[0];my$name=lc join('_',split /::/,$class);substr($name,4)}sub _xml_attr {return {}}sub _xml_content {defined $_[0]->{content}? $_[0]->{content}: ''}sub _error {$errstr=$_[1];undef}sub _clear {$errstr='';$_[0]}sub DESTROY {delete$_PARENT{refaddr $_[0]}}sub __equals {ref $_[1]and refaddr($_[0])==refaddr($_[1])}sub __nequals {!__equals(@_)}sub __eq {my$self=_INSTANCE($_[0],'PPI::Element')? $_[0]->content : $_[0];my$other=_INSTANCE($_[1],'PPI::Element')? $_[1]->content : $_[1];$self eq $other}sub __ne {!__eq(@_)}1;
PPI_ELEMENT

$fatpacked{"PPI/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_EXCEPTION';
  package PPI::Exception;use strict;use Params::Util qw{_INSTANCE};our$VERSION='1.271';sub new {my$class=shift;return bless {@_ },$class if @_ > 1;return bless {message=>$_[0]},$class if @_;return bless {message=>'Unknown Exception' },$class}sub throw {my$it=shift;if (_INSTANCE($it,'PPI::Exception')){if ($it->{callers}){push @{$it->{callers}},[caller(0)]}else {$it->{callers}||= []}}else {my$message=$_[0]|| 'Unknown Exception';$it=$it->new(message=>$message,callers=>[[caller(0)],],)}die$it}sub message {$_[0]->{message}}sub callers {@{$_[0]->{callers}|| []}}1;
PPI_EXCEPTION

$fatpacked{"PPI/Exception/ParserRejection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_EXCEPTION_PARSERREJECTION';
  package PPI::Exception::ParserRejection;use strict;use PPI::Exception ();our$VERSION='1.271';our@ISA='PPI::Exception';1;
PPI_EXCEPTION_PARSERREJECTION

$fatpacked{"PPI/Find.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_FIND';
  package PPI::Find;use strict;use Params::Util qw{_INSTANCE};our$VERSION='1.271';sub new {my$class=ref $_[0]? ref shift : shift;my$wanted=ref $_[0]eq 'CODE' ? shift : return undef;my$self=bless {wanted=>$wanted,},$class;$self}sub clone {my$self=ref $_[0]? shift : die "->clone can only be called as an object method";my$class=ref$self;my$clone=bless {wanted=>$self->{wanted},},$class;$clone}sub in {my$self=shift;my$Element=shift;my%params=@_;delete$self->{errstr};if ($self->{in}){return$self->_error('->in called while another search is in progress',%params)}unless (_INSTANCE($Element,'PPI::Element')){return$self->_error('->in was not passed a PPI::Element object',%params)}$self->{in}=$Element;$self->{matches}=[];if (!eval {$self->_execute;1}){my$errstr=$@;$errstr =~ s/\s+at\s+line\s+.+$//;return$self->_error("Error while searching: $errstr",%params)}delete$self->{in};if ($params{array_ref}){if (@{$self->{matches}}){return delete$self->{matches}}delete$self->{matches};return ''}my$matches=delete$self->{matches};@$matches}sub start {my$self=shift;my$Element=shift;delete$self->{errstr};if ($self->{in}){return$self->_error('->in called while another search is in progress')}unless (_INSTANCE($Element,'PPI::Element')){return$self->_error('->in was not passed a PPI::Element object')}$self->{in}=$Element;$self->{matches}=[];if (!eval {$self->_execute;1}){my$errstr=$@;$errstr =~ s/\s+at\s+line\s+.+$//;$self->_error("Error while searching: $errstr");return undef}1}sub match {my$self=shift;return undef unless$self->{matches};my$match=shift @{$self->{matches}};return$match if$match;$self->finish;undef}sub finish {my$self=shift;delete$self->{in};delete$self->{matches};delete$self->{errstr};1}sub _execute {my$self=shift;my$wanted=$self->{wanted};my@queue=($self->{in});while (my$Element=shift@queue){my$rv=&$wanted($Element,$self->{in});push @{$self->{matches}},$Element if$rv;next unless defined$rv;next unless$Element->isa('PPI::Node');if ($Element->isa('PPI::Structure')){unshift@queue,$Element->finish if$Element->finish;unshift@queue,$Element->children;unshift@queue,$Element->start if$Element->start}else {unshift@queue,$Element->children}}1}sub errstr {shift->{errstr}}sub _error {my$self=shift;$self->{errstr}=shift;my%params=@_;$params{array_ref}? undef : ()}1;
PPI_FIND

$fatpacked{"PPI/Lexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_LEXER';
  package PPI::Lexer;use strict;use Scalar::Util ();use Params::Util qw{_STRING _INSTANCE};use PPI ();use PPI::Exception ();use PPI::Singletons '%_PARENT';our$VERSION='1.271';our$errstr="";my%ROUND=('if'=>'PPI::Structure::Condition','elsif'=>'PPI::Structure::Condition','unless'=>'PPI::Structure::Condition','while'=>'PPI::Structure::Condition','until'=>'PPI::Structure::Condition','for'=>'PPI::Structure::For','foreach'=>'PPI::Structure::For',);my%RESOLVE=('('=>'_round','['=>'_square','{'=>'_curly',);our$X_TOKENIZER="PPI::Tokenizer";sub X_TOKENIZER {$X_TOKENIZER}sub new {my$class=shift->_clear;bless {Tokenizer=>undef,buffer=>[],delayed=>[],},$class}sub lex_file {my$self=ref $_[0]? shift : shift->new;my$file=_STRING(shift);unless (defined$file){return$self->_error("Did not pass a filename to PPI::Lexer::lex_file")}my$Tokenizer=eval {X_TOKENIZER->new($file)};if (_INSTANCE($@,'PPI::Exception')){return$self->_error($@->message)}elsif ($@){return$self->_error($errstr)}$self->lex_tokenizer($Tokenizer)}sub lex_source {my$self=ref $_[0]? shift : shift->new;my$source=shift;unless (defined$source and not ref$source){return$self->_error("Did not pass a string to PPI::Lexer::lex_source")}my$Tokenizer=eval {X_TOKENIZER->new(\$source)};if (_INSTANCE($@,'PPI::Exception')){return$self->_error($@->message)}elsif ($@){return$self->_error($errstr)}$self->lex_tokenizer($Tokenizer)}sub lex_tokenizer {my$self=ref $_[0]? shift : shift->new;my$Tokenizer=_INSTANCE(shift,'PPI::Tokenizer');return$self->_error("Did not pass a PPI::Tokenizer object to PPI::Lexer::lex_tokenizer")unless$Tokenizer;my$Document=PPI::Document->new;$self->{Tokenizer}=$Tokenizer;if (!eval {$self->_lex_document($Document);1}){undef$Document;if (_INSTANCE($@,'PPI::Exception')){return$self->_error($@->message)}else {return$self->_error($errstr)}}return$Document}sub _lex_document {my ($self,$Document)=@_;my$Token;while (ref($Token=$self->_get_token)){unless ($Token->significant){$self->_add_element($Document,$Token);next}if ($Token->content eq ';'){$self->_add_element($Document,PPI::Statement::Null->new($Token),);next}unless (ref$Token eq 'PPI::Token::Structure'){my$Statement=$self->_statement($Document,$Token)->new($Token);$self->_add_delayed($Document);$self->_add_element($Document,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__opens){$self->_rollback($Token);my$Statement=PPI::Statement->new;$self->_add_element($Document,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__closes){$self->_add_element($Document,PPI::Statement::UnmatchedBrace->new($Token));next}PPI::Exception->throw('Lexer reached an illegal state')}unless (defined$Token){my$errstr=$self->{Tokenizer}? $self->{Tokenizer}->errstr : '';$errstr ||= 'Unknown Tokenizer Error';PPI::Exception->throw($errstr)}$self->_add_delayed($Document);my$perl6=$self->{Tokenizer}->{'perl6'};if (@$perl6){my$includes=$Document->find('PPI::Statement::Include::Perl6');for my$include (@$includes){unless (@$perl6){PPI::Exception->throw('Failed to find a perl6 section')}$include->{perl6}=shift @$perl6}}return 1}my%STATEMENT_CLASSES=('BEGIN'=>'PPI::Statement::Scheduled','CHECK'=>'PPI::Statement::Scheduled','UNITCHECK'=>'PPI::Statement::Scheduled','INIT'=>'PPI::Statement::Scheduled','END'=>'PPI::Statement::Scheduled','AUTOLOAD'=>'PPI::Statement::Sub','DESTROY'=>'PPI::Statement::Sub','package'=>'PPI::Statement::Package','no'=>'PPI::Statement::Include','require'=>'PPI::Statement::Include','my'=>'PPI::Statement::Variable','local'=>'PPI::Statement::Variable','our'=>'PPI::Statement::Variable','state'=>'PPI::Statement::Variable','if'=>'PPI::Statement::Compound','unless'=>'PPI::Statement::Compound','for'=>'PPI::Statement::Compound','foreach'=>'PPI::Statement::Compound','while'=>'PPI::Statement::Compound','until'=>'PPI::Statement::Compound','given'=>'PPI::Statement::Given','when'=>'PPI::Statement::When','default'=>'PPI::Statement::When','redo'=>'PPI::Statement::Break','next'=>'PPI::Statement::Break','last'=>'PPI::Statement::Break','return'=>'PPI::Statement::Break','goto'=>'PPI::Statement::Break','__DATA__'=>'PPI::Statement::Data','__END__'=>'PPI::Statement::End',);sub _statement {my ($self,$Parent,$Token)=@_;if ($Parent->isa('PPI::Structure::List')or $Parent->isa('PPI::Structure::Constructor')){if ($Token->isa('PPI::Token::Word')){my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}if ($Next->isa('PPI::Token::Operator')and $Next->content eq '=>'){$self->_rollback($Next);return 'PPI::Statement::Expression'}else {last}}$self->_rollback($Next)}}my$is_lexsub=0;my$class=$STATEMENT_CLASSES{$Token->content};if ($class){my$Next;while ($Next=$self->_get_token){if (!$Next->significant){push @{$self->{delayed}},$Next;next}if ($Token->content =~ /^(?:my|our|state)$/ and $Next->isa('PPI::Token::Word')and $Next->content eq 'sub'){$class=undef;$is_lexsub=1;last}last if !$Next->isa('PPI::Token::Operator')or $Next->content ne '=>';$self->_rollback($Next);return 'PPI::Statement'}$self->_rollback($Next)}if ($Parent->isa('PPI::Structure::Subscript')){unless ($class and $class->isa('PPI::Statement::Expression')){return 'PPI::Statement::Expression'}my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}if ($Next->content eq '}'){$self->_rollback($Next);return 'PPI::Statement::Expression'}else {$self->_rollback($Next);return$class}}$self->_rollback($Next);return 'PPI::Statement::Expression'}return$class if$class;if ($is_lexsub || $Token->content eq 'sub'){my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}my$sclass=$STATEMENT_CLASSES{$Next->content};if ($sclass and $sclass eq 'PPI::Statement::Scheduled'){$self->_rollback($Next);return 'PPI::Statement::Scheduled'}if ($Next->isa('PPI::Token::Word')){$self->_rollback($Next);return 'PPI::Statement::Sub'}$self->_rollback($Next);return 'PPI::Statement'}$self->_rollback($Next);return 'PPI::Statement::Sub'}if ($Token->content eq 'use'){my$Next;while ($Next=$self->_get_token){unless ($Next->significant){push @{$self->{delayed}},$Next;next}if ($Next->isa('PPI::Token::Operator')and $Next->content eq '=>'){$self->_rollback($Next);return 'PPI::Statement'}elsif ($Next->content eq 'v6'){$self->_rollback($Next);return 'PPI::Statement::Include::Perl6'}else {$self->_rollback($Next);return 'PPI::Statement::Include'}}$self->_rollback($Next);return 'PPI::Statement::Include'}if ($Parent->isa('PPI::Structure::Condition')){return 'PPI::Statement::Expression'}if ($Parent->isa('PPI::Structure::List')){return 'PPI::Statement::Expression'}if ($Parent->isa('PPI::Structure::Given')or $Parent->isa('PPI::Structure::When')){return 'PPI::Statement::Expression'}if (_INSTANCE($Token,'PPI::Token::Label')){return 'PPI::Statement::Compound'}return 'PPI::Statement'}sub _lex_statement {my ($self,$Statement)=@_;if ($Statement->isa('PPI::Statement::End')){return$self->_lex_end($Statement)}my$Token;while (ref($Token=$self->_get_token)){unless ($Token->significant){push @{$self->{delayed}},$Token;next}if ($Token->__LEXER__closes or $Token->isa('PPI::Token::Separator')){return$self->_rollback($Token)}unless ($Statement->__LEXER__normal){unless ($self->_continues($Statement,$Token)){return$self->_rollback($Token)}}unless ($Token->isa('PPI::Token::Structure')){$self->_add_element($Statement,$Token);next}if ($Token->content eq ';'){$self->_add_element($Statement,$Token);return 1}my$method=$RESOLVE{$Token->content};my$Structure=$self->$method($Statement)->new($Token);$self->_add_delayed($Statement);$self->_add_element($Statement,$Structure);$self->_lex_structure($Structure)}unless (defined$Token){PPI::Exception->throw}$self->_rollback}sub _lex_end {my ($self,$Statement)=@_;my$Token;while ($Token=$self->_get_token){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Token}=$Statement);push @{$Statement->{children}},$Token}unless (defined$Token){PPI::Exception->throw}$self->_rollback}sub _continues {my ($self,$Statement,$Token)=@_;if ($Statement->schildren==1 and $Statement->schild(0)->isa('PPI::Structure::Block')){return ''}return 1 if ref$Statement !~ /\b(?:Scheduled|Sub|Compound|Given|When|Package)$/;my@part=$Statement->schildren;my$LastChild=$part[-1];return!$LastChild->isa('PPI::Structure::Block')if!$Statement->isa('PPI::Statement::Compound');my$type=$Statement->type;if ($type eq 'if'){unless ($LastChild->isa('PPI::Structure::Block')){return 1}my$NextLast=$Statement->schild(-2);if ($NextLast and $NextLast->isa('PPI::Token')and $NextLast->isa('PPI::Token::Word')and $NextLast->content eq 'else'){return ''}if ($Token->isa('PPI::Token::Word')and ($Token->content eq 'else' or $Token->content eq 'elsif')){return 1}return ''}if ($type eq 'label'){if ($Token->isa('PPI::Token::Word')and $Token->content =~ /^(?:while|until|for|foreach)$/){return 1}if ($Token->isa('PPI::Token::Structure')&& $Token->content eq '{'){return 1}return ''}if ($LastChild->isa('PPI::Structure')and $LastChild->braces eq '()'){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}if ($type eq 'for'){if ($LastChild->isa('PPI::Token::Word')and $LastChild->content =~ /^for(?:each)?\z/){if (($Token->isa('PPI::Token::Structure')and $Token->content eq '(')or $Token->isa('PPI::Token::QuoteLike::Words')){return 1}if ($LastChild->isa('PPI::Token::QuoteLike::Words')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}$type='foreach'}elsif ($LastChild->isa('PPI::Structure::Block')){return ''}elsif ($LastChild->isa('PPI::Token::QuoteLike::Words')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}}if ($LastChild->isa('PPI::Token::Word')and $LastChild->content eq 'continue'){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}if ($LastChild->isa('PPI::Structure::Block')){if (_INSTANCE($part[-2],'PPI::Token::Word')and $part[-2]->content eq 'continue'){return ''}return$Token->isa('PPI::Token::Word')&& $Token->content eq 'continue'}if ($type eq 'block'){}if ($type eq 'while'){if ($LastChild->isa('PPI::Token::Word')and ($LastChild->content eq 'while' or $LastChild->content eq 'until')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '('}}if ($type eq 'foreach'){if ($LastChild->isa('PPI::Token::Symbol')){return 1 if$Token->isa('PPI::Token::Structure')&& $Token->content eq '(';return 1 if$Token->isa('PPI::Token::QuoteLike::Words');return ''}if ($LastChild->content eq 'foreach' or $LastChild->content eq 'for'){if ($Token->isa('PPI::Token::Word')and (($STATEMENT_CLASSES{$Token->content }|| '')eq 'PPI::Statement::Variable')){return 1}elsif ($Token->content =~ /^\$/){return 1}elsif ($Token->isa('PPI::Token::Structure')and $Token->content eq '('){return 1}elsif ($Token->isa('PPI::Token::QuoteLike::Words')){return 1}else {return ''}}if (($STATEMENT_CLASSES{$LastChild->content }|| '')eq 'PPI::Statement::Variable'){return$Token->content =~ /^\$/}if ($LastChild->isa('PPI::Token::QuoteLike::Words')){return$Token->isa('PPI::Token::Structure')&& $Token->content eq '{'}}PPI::Exception->throw("Illegal state in '$type' compound statement")}sub _round {my ($self,$Parent)=@_;my$Element=$Parent->schild(-1);if (_INSTANCE($Element,'PPI::Token::Word')){my$rclass=$ROUND{$Element->content};return$rclass if$rclass}if ($Parent->isa('PPI::Statement::Compound')){if ($Parent->type =~ /^for(?:each)?$/){return 'PPI::Structure::For'}}elsif ($Parent->isa('PPI::Statement::Given')){return 'PPI::Structure::Given'}elsif ($Parent->isa('PPI::Statement::When')){return 'PPI::Structure::When'}if (_INSTANCE($Element,'PPI::Token::Operator')and $Element->content eq '->'){$Element->{_dereference}=1}'PPI::Structure::List'}sub _square {my ($self,$Parent)=@_;my$Element=$Parent->schild(-1);if ($Element){if ($Element->isa('PPI::Token::Operator')and $Element->content eq '->'){$Element->{_dereference}=1;return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Structure::Subscript')){return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Token::Symbol')and $Element->content =~ /^(?:\$|\@)/){return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Token::Cast')and $Element->content =~ /^(?:\@|\%)/){my$prior=$Parent->schild(-2);if ($prior and $prior->isa('PPI::Token::Operator')and $prior->content eq '->'){return 'PPI::Structure::Subscript'}}}'PPI::Structure::Constructor'}my%CURLY_CLASSES=('sub'=>'PPI::Structure::Block','grep'=>'PPI::Structure::Block','map'=>'PPI::Structure::Block','sort'=>'PPI::Structure::Block','do'=>'PPI::Structure::Block','scalar'=>'PPI::Structure::Constructor','='=>'PPI::Structure::Constructor','||='=>'PPI::Structure::Constructor','&&='=>'PPI::Structure::Constructor','//='=>'PPI::Structure::Constructor','||'=>'PPI::Structure::Constructor','&&'=>'PPI::Structure::Constructor','//'=>'PPI::Structure::Constructor','?'=>'PPI::Structure::Constructor',':'=>'PPI::Structure::Constructor',','=>'PPI::Structure::Constructor','=>'=>'PPI::Structure::Constructor','+'=>'PPI::Structure::Constructor','return'=>'PPI::Structure::Constructor','bless'=>'PPI::Structure::Constructor',);my@CURLY_LOOKAHEAD_CLASSES=({},{';'=>'PPI::Structure::Block','}'=>'PPI::Structure::Constructor',},{'=>'=>'PPI::Structure::Constructor',},);sub _curly {my ($self,$Parent)=@_;my$Element=$Parent->schild(-1);my$content=$Element ? $Element->content : '';if ($Element){if ($content eq '->' and $Element->isa('PPI::Token::Operator')){$Element->{_dereference}=1;return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Structure::Subscript')){return 'PPI::Structure::Subscript'}if ($content =~ /^(?:\$|\@)/ and $Element->isa('PPI::Token::Symbol')){return 'PPI::Structure::Subscript'}if ($Element->isa('PPI::Token::Cast')and $Element->content =~ /^(?:\@|\%|\*)/){my$prior=$Parent->schild(-2);if ($prior and $prior->isa('PPI::Token::Operator')and $prior->content eq '->'){return 'PPI::Structure::Subscript'}}if ($Element->isa('PPI::Structure::Block')){if (my$prior=$Parent->schild(-2)){my$prior_content=$prior->content();$prior->isa('PPI::Token::Cast')and ($prior_content eq '@' || $prior_content eq '$')and return 'PPI::Structure::Subscript'}}return 'PPI::Structure::Block' if$Parent->isa('PPI::Statement::Sub');return 'PPI::Structure::Block' if$Parent->isa('PPI::Statement::Package');if ($CURLY_CLASSES{$content}){return$CURLY_CLASSES{$content}}}if ($Parent->isa('PPI::Statement::Compound')){return 'PPI::Structure::Block'}if ($Parent->isa('PPI::Statement::Include')){if ($Parent->schildren==2 || $Parent->schildren==3 && $Parent->schild(2)->isa('PPI::Token::Number')){return 'PPI::Structure::Constructor'}}return 'PPI::Structure::Block' if$Element;if ($Parent->isa('PPI::Statement')and _INSTANCE($Parent->parent,'PPI::Structure::List')){my$function=$Parent->parent->parent->schild(-2);return 'PPI::Structure::Block' if$function and $function->content =~ /^(?:map|grep|sort|eval|do)$/;return 'PPI::Structure::Constructor' if not $function or $function->content !~ /^(?:print|say)$/}my$Next;my$position=0;my@delayed;while ($Next=$self->_get_token){unless ($Next->significant){push@delayed,$Next;next}if (++$position >= @CURLY_LOOKAHEAD_CLASSES){$self->_buffer(splice(@delayed),$Next);last}elsif (my$class=$CURLY_LOOKAHEAD_CLASSES[$position]{$Next->content}){$self->_buffer(splice(@delayed),$Next);return$class}push@delayed,$Next}$self->_buffer(splice(@delayed));if (ref$Parent eq 'PPI::Statement'){bless$Parent,'PPI::Statement::Compound'}return 'PPI::Structure::Block'}sub _lex_structure {my ($self,$Structure)=@_;my$Token;while (ref($Token=$self->_get_token)){unless ($Token->significant){push @{$self->{delayed}},$Token;next}unless ($Token->isa('PPI::Token::Structure')){$self->_add_delayed($Structure);my$Statement=$self->_statement($Structure,$Token)->new($Token);$self->_add_element($Structure,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__opens){$self->_rollback($Token);my$Statement=PPI::Statement->new;$self->_add_element($Structure,$Statement);$self->_lex_statement($Statement);next}if ($Token->__LEXER__closes){if ($Token->content eq $Structure->start->__LEXER__opposite){$self->_add_delayed($Structure);$Structure->{finish}=$Token;Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Token}=$Structure);if ($Structure->isa('PPI::Structure::For')){if (2 > scalar grep {$_->isa('PPI::Statement')}$Structure->children){bless($Structure,'PPI::Structure::List')}}return 1}return$self->_rollback($Token)}$self->_add_element($Structure,PPI::Statement::Null->new($Token),)}unless (defined$Token){PPI::Exception->throw}$self->_add_delayed($Structure)}sub _get_token {shift(@{$_[0]->{buffer}})or $_[0]->{Tokenizer}->get_token}sub _add_element {my ($self,$Parent,$Element)=@_;if (ref$Parent eq 'PPI::Statement' and my$first=$Parent->schild(0)){if ($first->isa('PPI::Token::Label')and!(my$second=$Parent->schild(1))){my$new_class=$STATEMENT_CLASSES{$second->content};bless$Parent,$new_class if$new_class}}for my$el (@{$self->{delayed}}){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$el}=$Parent)}Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Element}=$Parent);push @{$Parent->{children}},@{$self->{delayed}},$Element;$self->{delayed}=[]}sub _add_delayed {my ($self,$Parent)=@_;for my$el (@{$self->{delayed}}){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$el}=$Parent)}push @{$Parent->{children}},@{$self->{delayed}};$self->{delayed}=[]}sub _rollback {my$self=shift;if (@_){unshift @{$self->{buffer}},splice @_}if (@{$self->{delayed}}){unshift @{$self->{buffer}},splice @{$self->{delayed}}}1}sub _buffer {my$self=shift;if (@_){unshift @{$self->{buffer}},splice @_}1}sub _error {$errstr=$_[1];undef}sub _clear {$errstr='';$_[0]}sub errstr {$errstr}1;
PPI_LEXER

$fatpacked{"PPI/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NODE';
  package PPI::Node;use strict;use Carp ();use Scalar::Util qw{refaddr};use List::Util ();use Params::Util qw{_INSTANCE _CLASS _CODELIKE _NUMBER};use PPI::Element ();use PPI::Singletons '%_PARENT';our$VERSION='1.271';our@ISA="PPI::Element";sub new {my$class=ref $_[0]|| $_[0];bless {children=>[]},$class}sub scope() {''}sub add_element {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;$_PARENT{refaddr$Element}and return undef;push @{$self->{children}},$Element;Scalar::Util::weaken($_PARENT{refaddr$Element}=$self);1}sub __add_element {Scalar::Util::weaken($_PARENT{refaddr $_[1]}=$_[0]);push @{$_[0]->{children}},$_[1]}sub elements {if (wantarray){return @{$_[0]->{children}}}else {return scalar @{$_[0]->{children}}}}sub first_element {$_[0]->{children}->[0]}sub last_element {$_[0]->{children}->[-1]}sub children {wantarray ? @{$_[0]->{children}}: scalar @{$_[0]->{children}}}sub schildren {return grep {$_->significant}@{$_[0]->{children}}if wantarray;my$count=0;for (@{$_[0]->{children}}){$count++ if $_->significant}return$count}sub child {my ($self,$index)=@_;PPI::Exception->throw("method child() needs an index")if not defined _NUMBER$index;$self->{children}->[$index]}sub schild {my$self=shift;my$idx=0 + shift;my$el=$self->{children};if ($idx < 0){my$cursor=0;while (exists$el->[--$cursor]){return$el->[$cursor]if$el->[$cursor]->significant and ++$idx >= 0}}else {my$cursor=-1;while (exists$el->[++$cursor]){return$el->[$cursor]if$el->[$cursor]->significant and --$idx < 0}}undef}sub contains {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;while ($Element=$Element->parent){return 1 if refaddr($self)==refaddr($Element)}''}sub find {my$self=shift;my$wanted=$self->_wanted(shift)or return undef;my@found;my@queue=@{$self->{children}};my$ok=eval {while (@queue){my$Element=shift@queue;my$rv=&$wanted($self,$Element);push@found,$Element if$rv;next unless defined$rv;next unless$Element->isa('PPI::Node');if ($Element->isa('PPI::Structure')){unshift@queue,$Element->finish if$Element->finish;unshift@queue,@{$Element->{children}};unshift@queue,$Element->start if$Element->start}else {unshift@queue,@{$Element->{children}}}}1};if (!$ok){return undef}@found ? \@found : ''}sub find_first {my$self=shift;my$wanted=$self->_wanted(shift)or return undef;my@queue=@{$self->{children}};my$rv;my$ok=eval {while (@queue){my$Element=shift@queue;my$element_rv=$wanted->($self,$Element);if ($element_rv){$rv=$Element;last}next if!defined$element_rv;next if!$Element->isa('PPI::Node');if ($Element->isa('PPI::Structure')){unshift@queue,$Element->finish if defined($Element->finish);unshift@queue,@{$Element->{children}};unshift@queue,$Element->start if defined($Element->start)}else {unshift@queue,@{$Element->{children}}}}1};if (!$ok){return undef}$rv or ''}sub find_any {my$self=shift;my$rv=$self->find_first(@_);$rv ? 1 : $rv}sub remove_child {my$self=shift;my$child=_INSTANCE(shift,'PPI::Element')or return undef;my$key=refaddr$child;my$p=List::Util::first {refaddr$self->{children}[$_]==$key}0..$#{$self->{children}};return undef unless defined$p;splice(@{$self->{children}},$p,1);delete$_PARENT{refaddr$child};$child}sub prune {my$self=shift;my$wanted=$self->_wanted(shift)or return undef;my$pruned=0;my@queue=$self->children;my$ok=eval {while (my$element=shift@queue){my$rv=&$wanted($self,$element);if ($rv){$element->delete or return undef;$pruned++;next}next unless defined$rv;if (_INSTANCE($element,'PPI::Node')){unshift@queue,$element->children}}1};if (!$ok){return undef}$pruned}sub _wanted {my$either=shift;my$it=defined($_[0])? shift : do {Carp::carp('Undefined value passed as search condition')if $^W;return undef};return$it if _CODELIKE($it);if (ref$it){Carp::carp('Illegal non-CODE reference passed as search condition')if $^W;return undef}$it="PPI::$it" unless substr($it,0,5)eq 'PPI::';unless (_CLASS($it)and $it->isa('PPI::Element')){Carp::carp("Cannot create search condition for '$it': Not a PPI::Element")if $^W;return undef}my$wanted_class="\n\treturn '' unless \$_[1]->isa('$it');";my$wanted_content='';if (defined $_[0]){my$content=shift;if (ref$content eq 'Regexp'){$content="$content"}elsif (ref$content){Carp::carp("Cannot create search condition for '$it': Not a PPI::Element")if $^W;return undef}else {$content=quotemeta$content}$wanted_content .= "\n\treturn '' unless defined \$_[1]->{content};";$wanted_content .= "\n\treturn '' unless \$_[1]->{content} =~ /$content/;"}my$code="sub {" .$wanted_class .$wanted_content ."\n\t1;" ."\n}";$code=eval$code;(ref$code eq 'CODE')? $code : undef}sub tokens {map {$_->tokens}@{$_[0]->{children}}}sub content {join '',map {$_->content}@{$_[0]->{children}}}sub clone {my$self=shift;my$clone=$self->SUPER::clone;$clone->__link_children;$clone}sub location {my$self=shift;my$first=$self->{children}->[0]or return undef;$first->location}sub DESTROY {local $_;if ($_[0]->{children}){my@queue=$_[0];while (defined($_=shift@queue)){unshift@queue,@{delete $_->{children}}if $_->{children};%$_=()}}delete$_PARENT{refaddr $_[0]}}sub __position {my$key=refaddr $_[1];List::Util::first {refaddr $_[0]{children}[$_]==$key}0..$#{$_[0]{children}}}sub __insert_before_child {my$self=shift;my$key=refaddr shift;my$p=List::Util::first {refaddr$self->{children}[$_]==$key}0..$#{$self->{children}};for (@_){Scalar::Util::weaken($_PARENT{refaddr $_}=$self)}splice(@{$self->{children}},$p,0,@_);1}sub __insert_after_child {my$self=shift;my$key=refaddr shift;my$p=List::Util::first {refaddr$self->{children}[$_]==$key}0..$#{$self->{children}};for (@_){Scalar::Util::weaken($_PARENT{refaddr $_}=$self)}splice(@{$self->{children}},$p + 1,0,@_);1}sub __replace_child {my$self=shift;my$key=refaddr shift;my$p=List::Util::first {refaddr$self->{children}[$_]==$key}0..$#{$self->{children}};for (@_){Scalar::Util::weaken($_PARENT{refaddr $_}=$self)}splice(@{$self->{children}},$p,1,@_);1}sub __link_children {my$self=shift;my@queue=($self);while (my$Node=shift@queue){for my$Element (@{$Node->{children}}){Scalar::Util::weaken($_PARENT{refaddr($Element)}=$Node);unshift@queue,$Element if$Element->isa('PPI::Node')}next unless$Node->isa('PPI::Structure');Scalar::Util::weaken($_PARENT{refaddr($Node->start)}=$Node)if$Node->start;Scalar::Util::weaken($_PARENT{refaddr($Node->finish)}=$Node)if$Node->finish}1}1;
PPI_NODE

$fatpacked{"PPI/Normal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NORMAL';
  package PPI::Normal;use strict;use Carp ();use List::Util 1.33 ();use PPI::Util '_Document';use PPI::Document::Normalized ();use PPI::Normal::Standard ();use PPI::Singletons '%LAYER';our$VERSION='1.271';PPI::Normal::Standard->import;sub register {my$class=shift;while (@_){my$function=shift;SCOPE: {no strict 'refs';defined$function and defined &{"$function"}or Carp::croak("Bad function name provided to PPI::Normal")}if (List::Util::any {$_ eq $function}map @{$_},values%LAYER){return 1}my$layer=shift;defined$layer and $layer =~ /^(?:1|2)$/ or Carp::croak("Bad layer provided to PPI::Normal");push @{$LAYER{$layer}},$function}1}sub new {my$class=shift;my$layer=@_ ? (defined $_[0]and!ref $_[0]and $_[0]=~ /^[12]$/)? shift : return undef : 1;my$object=bless {layer=>$layer,},$class;$object}sub layer {$_[0]->{layer}}sub process {my$self=ref $_[0]? shift : shift->new;return undef if$self->{Document};$self->{Document}=_Document(shift)or return undef;my@functions=map {@{$LAYER{$_}}}(1 .. $self->layer);for my$function (@functions){no strict 'refs';&{"$function"}($self->{Document})}my$Normalized=PPI::Document::Normalized->new(Document=>$self->{Document},version=>__PACKAGE__->VERSION,functions=>\@functions,)or return undef;delete$self->{Document};return$Normalized}1;
PPI_NORMAL

$fatpacked{"PPI/Normal/Standard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NORMAL_STANDARD';
  package PPI::Normal::Standard;use strict;our$VERSION='1.271';my@METHODS=(remove_insignificant_elements=>1,remove_useless_attributes=>1,remove_useless_pragma=>2,remove_statement_separator=>2,remove_useless_return=>2,);sub import {PPI::Normal->register(map {/\D/ ? "PPI::Normal::Standard::$_" : $_}@METHODS)or die "Failed to register PPI::Normal::Standard transforms"}sub remove_insignificant_elements {my$Document=shift;$Document->prune(sub {!$_[1]->significant})}sub remove_useless_attributes {my$Document=shift;delete$Document->{tab_width}}my$remove_pragma=map {$_=>1}qw{strict warnings diagnostics less};sub remove_useless_pragma {my$Document=shift;$Document->prune(sub {return '' unless $_[1]->isa('PPI::Statement::Include');return 1 if $_[1]->version;return 1 if$remove_pragma->{$_[1]->pragma};''})}sub remove_statement_separator {my$Document=shift;$Document->prune(sub {$_[1]->isa('PPI::Token::Structure')or return '';$_[1]->content eq ';' or return '';my$stmt=$_[1]->parent or return '';$stmt->isa('PPI::Statement')or return '';$_[1]->next_sibling and return '';1})}sub remove_useless_return {my$Document=shift;$Document->prune(sub {$_[1]->isa('PPI::Token::Word')or return '';$_[1]->content eq 'return' or return '';my$stmt=$_[1]->parent or return '';$stmt->isa('PPI::Statement::Break')or return '';$stmt->children==2 or return '';$stmt->next_sibling and return '';my$block=$stmt->parent or return '';$block->isa('PPI::Structure::Block')or return '';1})}1;
PPI_NORMAL_STANDARD

$fatpacked{"PPI/Singletons.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_SINGLETONS';
  package PPI::Singletons;use strict;use Exporter ();our$VERSION='1.271';our@ISA='Exporter';our@EXPORT_OK=qw{%_PARENT %OPERATOR %MAGIC %LAYER $CURLY_SYMBOL %QUOTELIKE %KEYWORDS};our%_PARENT;our%OPERATOR=map {$_=>1}(qw{-> ++ -- ** ! ~ + - =~ !~ * / % x . << >> < > <= >= lt gt le ge == != <=> eq ne cmp ~~ & | ^ && || // .. ... ? : = **= += -= .= *= /= %= x= &= |= ^= <<= >>= &&= ||= //= => <> <<>> and or xor not},',');our%MAGIC=map {$_=>1}qw{$1 $2 $3 $4 $5 $6 $7 $8 $9 $_ $& $` $' $+ @+ %+ $* $. $/ $| $\\ $" $; $% $= $- @- %- $) $~ $^ $: $? $! %! $@ $$ $< $> $( $0 $[ $] @_ @* $^L $^A $^E $^C $^D $^F $^H $^I $^M $^N $^O $^P $^R $^S $^T $^V $^W $^X %^H $::|},'$}','$,','$#','$#+','$#-';our%LAYER=(1=>[],2=>[]);our$CURLY_SYMBOL=qr{\G\^[[:upper:]_]\w+\}};our%QUOTELIKE=('q'=>'Quote::Literal','qq'=>'Quote::Interpolate','qx'=>'QuoteLike::Command','qw'=>'QuoteLike::Words','qr'=>'QuoteLike::Regexp','m'=>'Regexp::Match','s'=>'Regexp::Substitute','tr'=>'Regexp::Transliterate','y'=>'Regexp::Transliterate',);our%KEYWORDS=map {$_=>1}qw{abs accept alarm and atan2 bind binmode bless break caller chdir chmod chomp chop chown chr chroot close closedir cmp connect continue cos crypt dbmclose dbmopen default defined delete die do dump each else elsif endgrent endhostent endnetent endprotoent endpwent endservent eof eq eval evalbytes exec exists exit exp fc fcntl fileno flock for foreach fork format formline ge getc getgrent getgrgid getgrnam gethostbyaddr gethostbyname gethostent getlogin getnetbyaddr getnetbyname getnetent getpeername getpgrp getppid getpriority getprotobyname getprotobynumber getprotoent getpwent getpwnam getpwuid getservbyname getservbyport getservent getsockname getsockopt given glob gmtime goto grep gt hex if index int ioctl join keys kill last lc lcfirst le length link listen local localtime lock log lstat lt m map mkdir msgctl msgget msgrcv msgsnd my ne next no not oct open opendir or ord our pack package pipe pop pos print printf prototype push q qq qr quotemeta qw qx rand read readdir readline readlink readpipe recv redo ref rename require reset return reverse rewinddir rindex rmdir s say scalar seek seekdir select semctl semget semop send setgrent sethostent setnetent setpgrp setpriority setprotoent setpwent setservent setsockopt shift shmctl shmget shmread shmwrite shutdown sin sleep socket socketpair sort splice split sprintf sqrt srand stat state study sub substr symlink syscall sysopen sysread sysseek system syswrite tell telldir tie tied time times tr truncate uc ucfirst umask undef unless unlink unpack unshift untie until use utime values vec wait waitpid wantarray warn when while write x xor y};1;
PPI_SINGLETONS

$fatpacked{"PPI/Statement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT';
  package PPI::Statement;use strict;use Scalar::Util ();use Params::Util qw{_INSTANCE};use PPI::Node ();use PPI::Exception ();use PPI::Singletons '%_PARENT';our$VERSION='1.271';our@ISA="PPI::Node";use PPI::Statement::Break ();use PPI::Statement::Compound ();use PPI::Statement::Data ();use PPI::Statement::End ();use PPI::Statement::Expression ();use PPI::Statement::Include ();use PPI::Statement::Null ();use PPI::Statement::Package ();use PPI::Statement::Scheduled ();use PPI::Statement::Sub ();use PPI::Statement::Given ();use PPI::Statement::UnmatchedBrace ();use PPI::Statement::Unknown ();use PPI::Statement::Variable ();use PPI::Statement::When ();sub __LEXER__normal() {1}sub new {my$class=shift;if (ref$class){PPI::Exception->throw}my$self=bless {children=>[],},$class;my$token=shift;if (_INSTANCE($token,'PPI::Token')){Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$token}=$self);push @{$self->{children}},$token}$self}sub label {my$first=shift->schild(1)or return '';$first->isa('PPI::Token::Label')? substr($first,0,length($first)- 1): ''}sub specialized {__PACKAGE__ ne ref $_[0]}sub stable {die "The ->stable method has not yet been implemented"}sub _complete {my$self=shift;my$semi=$self->schild(-1);return!!(defined$semi and $semi->isa('PPI::Token::Structure')and $semi->content eq ';')}sub insert_before {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Statement')){return$self->__insert_before($Element)}elsif ($Element->isa('PPI::Token')and!$Element->significant){return$self->__insert_before($Element)}''}sub insert_after {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Statement')){return$self->__insert_after($Element)}elsif ($Element->isa('PPI::Token')and!$Element->significant){return$self->__insert_after($Element)}''}1;
PPI_STATEMENT

$fatpacked{"PPI/Statement/Break.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_BREAK';
  package PPI::Statement::Break;use strict;use PPI::Statement ();our$VERSION='1.271';our@ISA="PPI::Statement";1;
PPI_STATEMENT_BREAK

$fatpacked{"PPI/Statement/Compound.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_COMPOUND';
  package PPI::Statement::Compound;use strict;use PPI::Statement ();our$VERSION='1.271';our@ISA="PPI::Statement";my%TYPES=('if'=>'if','unless'=>'if','while'=>'while','until'=>'while','for'=>'for','foreach'=>'foreach',);sub __LEXER__normal() {''}sub type {my$self=shift;my$p=0;my$Element=$self->schild($p)or return undef;if ($Element->isa('PPI::Token::Label')){$Element=$self->schild(++$p)or return 'label'}my$content=$Element->content;if ($content =~ /^for(?:each)?\z/){$Element=$self->schild(++$p)or return$content;if ($Element->isa('PPI::Token')){return 'foreach' if$Element->content =~ /^my|our|state\z/;return 'foreach' if$Element->isa('PPI::Token::Symbol');return 'foreach' if$Element->isa('PPI::Token::QuoteLike::Words')}if ($Element->isa('PPI::Structure::List')){return 'foreach'}return 'for'}return$TYPES{$content}if$Element->isa('PPI::Token::Word');return 'continue' if$Element->isa('PPI::Structure::Block');undef}sub scope() {1}sub _complete {my$self=shift;my$type=$self->type or die "Illegal compound statement type";if ($type eq 'if'){my$child=$self->schild(-1)or return '';$child->isa('PPI::Structure')or return '';$child->braces eq '{}' or return '';$child->_complete or return ''}elsif ($type eq 'while'){die "CODE INCOMPLETE"}else {die "CODE INCOMPLETE"}}1;
PPI_STATEMENT_COMPOUND

$fatpacked{"PPI/Statement/Data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_DATA';
  package PPI::Statement::Data;use strict;use PPI::Statement ();our$VERSION='1.271';our@ISA="PPI::Statement";sub _complete () {''}1;
PPI_STATEMENT_DATA

$fatpacked{"PPI/Statement/End.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_END';
  package PPI::Statement::End;use strict;use PPI::Statement ();our$VERSION='1.271';our@ISA="PPI::Statement";sub _complete () {1}1;
PPI_STATEMENT_END

$fatpacked{"PPI/Statement/Expression.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_EXPRESSION';
  package PPI::Statement::Expression;use strict;use PPI::Statement ();our$VERSION='1.271';our@ISA="PPI::Statement";1;
PPI_STATEMENT_EXPRESSION

$fatpacked{"PPI/Statement/Given.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_GIVEN';
  package PPI::Statement::Given;use strict;use PPI::Statement ();our$VERSION='1.271';our@ISA="PPI::Statement";sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub scope() {1}1;
PPI_STATEMENT_GIVEN

$fatpacked{"PPI/Statement/Include.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_INCLUDE';
  package PPI::Statement::Include;use strict;use PPI::Statement ();use PPI::Statement::Include::Perl6 ();our$VERSION='1.271';our@ISA="PPI::Statement";sub type {my$self=shift;my$keyword=$self->schild(0)or return undef;$keyword->isa('PPI::Token::Word')and $keyword->content}sub module {my$self=shift;my$module=$self->schild(1)or return undef;$module->isa('PPI::Token::Word')and $module->content}sub module_version {my$self=shift;my$argument=$self->schild(3);if ($argument and $argument->isa('PPI::Token::Operator')){return undef}my$version=$self->schild(2)or return undef;return undef unless$version->isa('PPI::Token::Number');return$version}sub pragma {my$self=shift;my$module=$self->module or return '';$module =~ /^[a-z][a-z\d]*$/ ? $module : ''}sub version {my$self=shift;my$version=$self->schild(1)or return undef;$version->isa('PPI::Token::Number')? $version->content : ''}sub version_literal {my$self=shift;my$version=$self->schild(1)or return undef;$version->isa('PPI::Token::Number')? $version->literal : ''}sub arguments {my$self=shift;my@args=$self->schildren;shift@args;if ($args[-1]->isa('PPI::Token::Structure')and $args[-1]->content eq ';'){pop@args}shift@args;return unless@args;if ($args[0]->isa('PPI::Token::Number')){my$after=$args[1]or return;$after->isa('PPI::Token::Operator')or shift@args}return@args}1;
PPI_STATEMENT_INCLUDE

$fatpacked{"PPI/Statement/Include/Perl6.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_INCLUDE_PERL6';
  package PPI::Statement::Include::Perl6;use strict;use PPI::Statement::Include ();our$VERSION='1.271';our@ISA="PPI::Statement::Include";sub perl6 {$_[0]->{perl6}}1;
PPI_STATEMENT_INCLUDE_PERL6

$fatpacked{"PPI/Statement/Null.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_NULL';
  package PPI::Statement::Null;use strict;use PPI::Statement ();our$VERSION='1.271';our@ISA="PPI::Statement";sub significant() {''}1;
PPI_STATEMENT_NULL

$fatpacked{"PPI/Statement/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_PACKAGE';
  package PPI::Statement::Package;use strict;use PPI::Statement ();our$VERSION='1.271';our@ISA="PPI::Statement";sub __LEXER__normal() {''}sub namespace {my$self=shift;my$namespace=$self->schild(1)or return '';$namespace->isa('PPI::Token::Word')? $namespace->content : ''}sub version {my$self=shift;my$version=$self->schild(2)or return '';$version->isa('PPI::Token::Structure')? '' : $version->content}sub file_scoped {my$self=shift;my ($Parent,$Document)=($self->parent,$self->top);$Parent and $Document and $Parent==$Document and $Document->isa('PPI::Document')and!$Document->isa('PPI::Document::Fragment')}1;
PPI_STATEMENT_PACKAGE

$fatpacked{"PPI/Statement/Scheduled.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_SCHEDULED';
  package PPI::Statement::Scheduled;use strict;use PPI::Statement::Sub ();our$VERSION='1.271';our@ISA="PPI::Statement::Sub";sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub type {my$self=shift;my@children=$self->schildren or return undef;$children[0]->content eq 'sub' ? $children[1]->content : $children[0]->content}sub name {shift->type(@_)}1;
PPI_STATEMENT_SCHEDULED

$fatpacked{"PPI/Statement/Sub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_SUB';
  package PPI::Statement::Sub;use strict;use List::Util ();use Params::Util qw{_INSTANCE};use PPI::Statement ();our$VERSION='1.271';our@ISA="PPI::Statement";sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub name {my ($self)=@_;my$token=$self->schild(1);return$token->content if defined$token and $token->isa('PPI::Token::Word');$token=$self->schild(0);return$token->content if defined$token and $token->isa('PPI::Token::Word');return ''}sub prototype {my$self=shift;my$Prototype=List::Util::first {_INSTANCE($_,'PPI::Token::Prototype')}$self->children;defined($Prototype)? $Prototype->prototype : undef}sub block {my$self=shift;my$lastchild=$self->schild(-1)or return '';$lastchild->isa('PPI::Structure::Block')and $lastchild}sub forward {!shift->block}sub reserved {my$self=shift;my$name=$self->name or return '';$name eq uc$name}sub type {my$self=shift;my@schild=grep {$_->significant}$self->children;shift@schild if _INSTANCE($schild[0],'PPI::Token::Label');(_INSTANCE($schild[0],'PPI::Token::Word')and $schild[0]->content =~ /^(my|our|state)$/)? $schild[0]->content : undef}1;
PPI_STATEMENT_SUB

$fatpacked{"PPI/Statement/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_UNKNOWN';
  package PPI::Statement::Unknown;use strict;use PPI::Statement ();our$VERSION='1.271';our@ISA="PPI::Statement";sub _complete () {1}1;
PPI_STATEMENT_UNKNOWN

$fatpacked{"PPI/Statement/UnmatchedBrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_UNMATCHEDBRACE';
  package PPI::Statement::UnmatchedBrace;use strict;use PPI::Statement ();our$VERSION='1.271';our@ISA="PPI::Statement";sub _complete () {1}1;
PPI_STATEMENT_UNMATCHEDBRACE

$fatpacked{"PPI/Statement/Variable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_VARIABLE';
  package PPI::Statement::Variable;use strict;use Params::Util qw{_INSTANCE};use PPI::Statement::Expression ();our$VERSION='1.271';our@ISA="PPI::Statement::Expression";sub type {my$self=shift;my@schild=grep {$_->significant}$self->children;shift@schild if _INSTANCE($schild[0],'PPI::Token::Label');(_INSTANCE($schild[0],'PPI::Token::Word')and $schild[0]->content =~ /^(my|local|our|state)$/)? $schild[0]->content : undef}sub variables {map {$_->canonical}$_[0]->symbols}sub symbols {my$self=shift;my@schild=grep {$_->significant}$self->children;shift@schild if _INSTANCE($schild[0],'PPI::Token::Label');if (_INSTANCE($schild[1],'PPI::Token::Symbol')){return$schild[1]}if (_INSTANCE($schild[1],'PPI::Structure::List')){my$Expression=$schild[1]->schild(0);$Expression and $Expression->isa('PPI::Statement::Expression')or return ();if ($self->type eq 'my' or $self->type eq 'our' or $self->type eq 'state'){return grep {$_->isa('PPI::Token::Symbol')}$Expression->schildren}return grep {$self->_local_variable($_)}grep {$_->isa('PPI::Token::Symbol')}$Expression->schildren}()}sub _local_variable {my ($self,$el)=@_;my$n=$el->snext_sibling or return 1;my$p=$el->sprevious_sibling;if (!$p or $p eq ','){return 1 if$n eq ',';return 1 if$n eq '='}return ''}1;
PPI_STATEMENT_VARIABLE

$fatpacked{"PPI/Statement/When.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_WHEN';
  package PPI::Statement::When;use strict;use PPI::Statement ();our$VERSION='1.271';our@ISA="PPI::Statement";sub __LEXER__normal() {''}sub _complete {my$child=$_[0]->schild(-1);return!!(defined$child and $child->isa('PPI::Structure::Block')and $child->complete)}sub scope() {1}1;
PPI_STATEMENT_WHEN

$fatpacked{"PPI/Structure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE';
  package PPI::Structure;use strict;use Scalar::Util ();use Params::Util qw{_INSTANCE};use PPI::Node ();use PPI::Exception ();use PPI::Singletons '%_PARENT';our$VERSION='1.271';our@ISA="PPI::Node";use PPI::Structure::Block ();use PPI::Structure::Condition ();use PPI::Structure::Constructor ();use PPI::Structure::For ();use PPI::Structure::Given ();use PPI::Structure::List ();use PPI::Structure::Subscript ();use PPI::Structure::Unknown ();use PPI::Structure::When ();sub new {my$class=shift;my$Token=PPI::Token::__LEXER__opens($_[0])? shift : return undef;my$self=bless {children=>[],start=>$Token,},$class;Scalar::Util::weaken($_PARENT{Scalar::Util::refaddr$Token}=$self);$self}sub start {$_[0]->{start}}sub finish {$_[0]->{finish}}sub braces {my$self=$_[0]->{start}? shift : return undef;return {'['=>'[]','('=>'()','{'=>'{}',}->{$self->{start}->{content}}}sub complete {!!($_[0]->{start}and $_[0]->{finish})}sub elements {my$self=shift;if (wantarray){return ($self->{start}|| (),@{$self->{children}},$self->{finish}|| ())}else {return scalar(@{$self->{children}})+ ($self->{start}? 1 : 0)+ ($self->{finish}? 1 : 0)}}sub first_element {$_[0]->{start}or $_[0]->{children}->[0]or $_[0]->{finish}}sub last_element {$_[0]->{finish}or $_[0]->{children}->[-1]or $_[0]->{start}}sub location {my$self=shift;my$first=$self->first_element or return undef;$first->location}sub tokens {my$self=shift;my@tokens=($self->{start}|| (),$self->SUPER::tokens(@_),$self->{finish}|| (),);@tokens}sub content {my$self=shift;my$content=$self->{start}? $self->{start}->content : '';for my$child (@{$self->{children}}){$content .= $child->content}$content .= $self->{finish}->content if$self->{finish};$content}sub _complete {!!(defined $_[0]->{finish})}sub insert_before {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_before($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_before($Element)}''}sub insert_after {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_after($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_after($Element)}''}1;
PPI_STRUCTURE

$fatpacked{"PPI/Structure/Block.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_BLOCK';
  package PPI::Structure::Block;use strict;use PPI::Structure ();our$VERSION='1.271';our@ISA="PPI::Structure";sub scope() {1}1;
PPI_STRUCTURE_BLOCK

$fatpacked{"PPI/Structure/Condition.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_CONDITION';
  package PPI::Structure::Condition;use strict;use PPI::Structure ();our$VERSION='1.271';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_CONDITION

$fatpacked{"PPI/Structure/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_CONSTRUCTOR';
  package PPI::Structure::Constructor;use strict;use PPI::Structure ();our$VERSION='1.271';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_CONSTRUCTOR

$fatpacked{"PPI/Structure/For.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_FOR';
  package PPI::Structure::For;use strict;use PPI::Structure ();our$VERSION='1.271';our@ISA="PPI::Structure";my$has_warned=0;sub isa {if ($_[1]and $_[1]eq 'PPI::Structure::ForLoop'){unless ($has_warned){warn("PPI::Structure::ForLoop has been deprecated");$has_warned=1}return 1}return shift->SUPER::isa(@_)}1;
PPI_STRUCTURE_FOR

$fatpacked{"PPI/Structure/Given.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_GIVEN';
  package PPI::Structure::Given;use strict;use PPI::Structure ();our$VERSION='1.271';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_GIVEN

$fatpacked{"PPI/Structure/List.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_LIST';
  package PPI::Structure::List;use strict;use Carp ();use PPI::Structure ();our$VERSION='1.271';our@ISA="PPI::Structure";my$has_warned=0;sub isa {if ($_[1]and $_[1]eq 'PPI::Structure::ForLoop'){if ($_[0]->parent->isa('PPI::Statement::Compound')and $_[0]->parent->type =~ /^for/){unless ($has_warned){local$Carp::CarpLevel=$Carp::CarpLevel + 1;Carp::carp("PPI::Structure::ForLoop has been deprecated");$has_warned=1}return 1}}return shift->SUPER::isa(@_)}1;
PPI_STRUCTURE_LIST

$fatpacked{"PPI/Structure/Subscript.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_SUBSCRIPT';
  package PPI::Structure::Subscript;use strict;use PPI::Structure ();our$VERSION='1.271';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_SUBSCRIPT

$fatpacked{"PPI/Structure/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_UNKNOWN';
  package PPI::Structure::Unknown;use strict;use PPI::Structure ();our$VERSION='1.271';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_UNKNOWN

$fatpacked{"PPI/Structure/When.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_WHEN';
  package PPI::Structure::When;use strict;use PPI::Structure ();our$VERSION='1.271';our@ISA="PPI::Structure";1;
PPI_STRUCTURE_WHEN

$fatpacked{"PPI/Token.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN';
  package PPI::Token;use strict;use Params::Util qw{_INSTANCE};use PPI::Element ();use PPI::Exception ();our$VERSION='1.271';our@ISA='PPI::Element';use PPI::Token::BOM ();use PPI::Token::Whitespace ();use PPI::Token::Comment ();use PPI::Token::Pod ();use PPI::Token::Number ();use PPI::Token::Number::Binary ();use PPI::Token::Number::Octal ();use PPI::Token::Number::Hex ();use PPI::Token::Number::Float ();use PPI::Token::Number::Exp ();use PPI::Token::Number::Version ();use PPI::Token::Word ();use PPI::Token::DashedWord ();use PPI::Token::Symbol ();use PPI::Token::ArrayIndex ();use PPI::Token::Magic ();use PPI::Token::Quote::Single ();use PPI::Token::Quote::Double ();use PPI::Token::Quote::Literal ();use PPI::Token::Quote::Interpolate ();use PPI::Token::QuoteLike::Backtick ();use PPI::Token::QuoteLike::Command ();use PPI::Token::QuoteLike::Regexp ();use PPI::Token::QuoteLike::Words ();use PPI::Token::QuoteLike::Readline ();use PPI::Token::Regexp::Match ();use PPI::Token::Regexp::Substitute ();use PPI::Token::Regexp::Transliterate ();use PPI::Token::Operator ();use PPI::Token::Cast ();use PPI::Token::Structure ();use PPI::Token::Label ();use PPI::Token::HereDoc ();use PPI::Token::Separator ();use PPI::Token::Data ();use PPI::Token::End ();use PPI::Token::Prototype ();use PPI::Token::Attribute ();use PPI::Token::Unknown ();sub new {bless {content=>(defined $_[1]? "$_[1]" : '')},$_[0]}sub set_class {my$self=shift;my$class=substr($_[0],0,12)eq 'PPI::Token::' ? shift : 'PPI::Token::' .shift;my$old_quote=(ref($self)=~ /\b(?:Quote|Regex)\b/o)? 1 : 0;my$new_quote=($class =~ /\b(?:Quote|Regex)\b/o)? 1 : 0;bless$self,$class;return$class if ($old_quote - $new_quote)==0;my$token=$class->new($self->{content});%$self=%$token;return$class}sub set_content {$_[0]->{content}=$_[1]}sub add_content {$_[0]->{content}.= $_[1]}sub length {CORE::length($_[0]->{content})}sub content {$_[0]->{content}}sub insert_before {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_before($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_before($Element)}''}sub insert_after {my$self=shift;my$Element=_INSTANCE(shift,'PPI::Element')or return undef;if ($Element->isa('PPI::Structure')){return$self->__insert_after($Element)}elsif ($Element->isa('PPI::Token')){return$self->__insert_after($Element)}''}sub __TOKENIZER__on_line_start() {1}sub __TOKENIZER__on_line_end() {1}sub __TOKENIZER__on_char() {'Unknown'}sub __LEXER__opens {ref($_[0])eq 'PPI::Token::Structure' and $_[0]->{content}=~ /(?:\(|\[|\{)/}sub __LEXER__closes {ref($_[0])eq 'PPI::Token::Structure' and $_[0]->{content}=~ /(?:\)|\]|\})/}1;
PPI_TOKEN

$fatpacked{"PPI/Token/ArrayIndex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_ARRAYINDEX';
  package PPI::Token::ArrayIndex;use strict;use PPI::Token ();our$VERSION='1.271';our@ISA="PPI::Token";sub __TOKENIZER__on_char {my$t=$_[1];pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G([\w:']+)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_ARRAYINDEX

$fatpacked{"PPI/Token/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_ATTRIBUTE';
  package PPI::Token::Attribute;use strict;use PPI::Token ();our$VERSION='1.271';our@ISA="PPI::Token";sub identifier {my$self=shift;$self->{content}=~ /^(.+?)\(/ ? $1 : $self->{content}}sub parameters {my$self=shift;$self->{content}=~ /\((.*)\)$/ ? $1 : undef}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);unless ($char eq '('){return$t->_finalize_token->__TOKENIZER__on_char($t)}my$string=$class->__TOKENIZER__scan_for_end($t);if (ref$string){$t->{token}->{content}.= $$string;$t->_finalize_token;return 0}$t->{token}->{content}.= $string;$t->_finalize_token->__TOKENIZER__on_char($t)}sub __TOKENIZER__scan_for_end {my$t=$_[1];my$string='';my$depth=0;while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};unless ($t->{line}=~ /\G((?:\\.|[^()])*?[()])/gc){$string .= substr($t->{line},$t->{line_cursor});$t->_fill_line(1)or return \$string;$t->{line_cursor}=0;next}$string .= $1;$t->{line_cursor}+= length $1;$depth += ($1 =~ /\($/)? 1 : -1 and next;return$string}\$string}1;
PPI_TOKEN_ATTRIBUTE

$fatpacked{"PPI/Token/BOM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_BOM';
  package PPI::Token::BOM;use strict;use PPI::Token ();our$VERSION='1.271';our@ISA="PPI::Token";sub significant() {''}my%bom_types=("\x00\x00\xfe\xff"=>'UTF-32',"\xff\xfe\x00\x00"=>'UTF-32',"\xfe\xff"=>'UTF-16',"\xff\xfe"=>'UTF-16',"\xef\xbb\xbf"=>'UTF-8',);sub __TOKENIZER__on_line_start {my$t=$_[1];$_=$t->{line};if (m/^(\x00\x00\xfe\xff |  # UTF-32, big-endian
  		\xff\xfe\x00\x00 |  # UTF-32, little-endian
  		\xfe\xff         |  # UTF-16, big-endian
  		\xff\xfe         |  # UTF-16, little-endian
  		\xef\xbb\xbf)       # UTF-8
  	    /xs){my$bom=$1;if ($bom_types{$bom}ne 'UTF-8'){return$t->_error("$bom_types{$bom} is not supported")}$t->_new_token('BOM',$bom)or return undef;$t->{line_cursor}+= length$bom}$t->{class}='PPI::Token::Whitespace';return$t->{class}->__TOKENIZER__on_line_start($t)}1;
PPI_TOKEN_BOM

$fatpacked{"PPI/Token/Cast.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_CAST';
  package PPI::Token::Cast;use strict;use PPI::Token ();our$VERSION='1.271';our@ISA="PPI::Token";our%POSTFIX=map {$_=>1}(qw{%* @* $*},'$#*');sub __TOKENIZER__on_char {my$t=$_[1];my$char=substr($t->{line},$t->{line_cursor},1);my$content=$t->{token}->{content};return 1 if$POSTFIX{$content .$char };$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_CAST

$fatpacked{"PPI/Token/Comment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_COMMENT';
  package PPI::Token::Comment;use strict;use PPI::Token ();our$VERSION='1.271';our@ISA="PPI::Token";sub significant() {''}sub __TOKENIZER__on_char {my$t=$_[1];if (substr($t->{line},$t->{line_cursor},1)eq "\n"){return$t->_finalize_token->__TOKENIZER__on_char($t)}1}sub __TOKENIZER__commit {my$t=$_[1];my$rest=substr($t->{line},$t->{line_cursor});if (chomp$rest){$t->_new_token('Comment',$rest);$t->_new_token('Whitespace',"\n")}else {$t->_new_token('Comment',$rest)}$t->{line_cursor}=$t->{line_length}- 1;0}sub __TOKENIZER__on_line_end {$_[1]->_finalize_token if $_[1]->{token};1}sub line {$_[0]->{content}=~ /\n$/ ? 1 : 0}1;
PPI_TOKEN_COMMENT

$fatpacked{"PPI/Token/DashedWord.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_DASHEDWORD';
  package PPI::Token::DashedWord;use strict;use PPI::Token ();our$VERSION='1.271';our@ISA="PPI::Token";*literal=*PPI::Token::Word::literal;sub __TOKENIZER__on_char {my$t=$_[1];pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G(\w+)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}if ($t->{token}->{content}=~ /^\-[rwxoRWXOezsfdlpSbctugkTBMAC]$/){$t->{class}=$t->{token}->set_class('Operator')}else {$t->{class}=$t->{token}->set_class('Word')}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_DASHEDWORD

$fatpacked{"PPI/Token/Data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_DATA';
  package PPI::Token::Data;use strict;use IO::String 1.07 ();use PPI::Token ();our$VERSION='1.271';our@ISA="PPI::Token";sub handle {my$self=shift;IO::String->new(\$self->{content})}sub __TOKENIZER__on_line_start {my ($self,$t)=@_;if (defined$t->{token}){$t->{token}->{content}.= $t->{line}}else {defined($t->{token}=$t->{class}->new($t->{line}))or return undef}return 0}1;
PPI_TOKEN_DATA

$fatpacked{"PPI/Token/End.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_END';
  package PPI::Token::End;use strict;use PPI::Token ();our$VERSION='1.271';our@ISA="PPI::Token";sub significant() {''}sub __TOKENIZER__on_char() {1}sub __TOKENIZER__on_line_start {my$t=$_[1];if ($t->{line}=~ /^=(\w+)/){$t->_new_token('Pod',$t->{line});unless ($1 eq 'cut'){$t->{class}='PPI::Token::Pod'}}else {if (defined$t->{token}){$t->{token}->{content}.= $t->{line}}else {$t->_new_token('End',$t->{line})}}0}1;
PPI_TOKEN_END

$fatpacked{"PPI/Token/HereDoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_HEREDOC';
  package PPI::Token::HereDoc;use strict;our$VERSION='1.271';our@ISA="PPI::Token";sub heredoc {@{shift->{_heredoc}}}sub indentation {shift->{_indentation}}sub terminator {shift->{_terminator}}sub _is_terminator {my ($self,$terminator,$line,$indented)=@_;if ($indented){return$line =~ /^\s*\Q$terminator\E$/}else {return$line eq $terminator}}sub _indent {my ($self,$token)=@_;my ($indent)=$token->{_terminator_line}=~ /^(\s*)/;return$indent}sub _is_match_indent {my ($self,$token,$indent)=@_;return (grep {/^$indent/ || $_ eq "\n"}@{$token->{_heredoc}})==@{$token->{_heredoc}}}sub __TOKENIZER__on_char {my ($self,$t)=@_;pos$t->{line}=$t->{line_cursor};if ($t->{line}!~ m/\G( ~? \s* (?: "[^"]*" | '[^']*' | `[^`]*` | \\?\w+ ) )/gcx){$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}my$token=$t->{token};$token->{content}.= $1;$t->{line_cursor}+= length $1;my$content=$token->{content};if ($content =~ /^\<\<(~?)(\w+)$/){$token->{_mode}='interpolate';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2}elsif ($content =~ /^\<\<(~?)\s*\'(.*)\'$/){$token->{_mode}='literal';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2;$token->{_terminator}=~ s/\\'/'/g}elsif ($content =~ /^\<\<(~?)\s*\"(.*)\"$/){$token->{_mode}='interpolate';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2;$token->{_terminator}=~ s/\\"/"/g}elsif ($content =~ /^\<\<(~?)\s*\`(.*)\`$/){$token->{_mode}='command';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2;$token->{_terminator}=~ s/\\`/`/g}elsif ($content =~ /^\<\<(~?)\\(\w+)$/){$token->{_mode}='literal';$token->{_indented}=1 if $1 eq '~';$token->{_terminator}=$2}else {return undef}$token->{_heredoc}=\my@heredoc;my$terminator=$token->{_terminator}."\n";while (defined(my$line=$t->_get_line)){if ($self->_is_terminator($terminator,$line,$token->{_indented})){$token->{_terminator_line}=$line;if ($token->{_indented}){my$indent=$self->_indent($token);$token->{_indentation}=$indent;unless ($self->_is_match_indent($token,$indent)){push@heredoc,$line;last}s/^$indent// for@heredoc,$token->{_terminator_line}}return$t->_finalize_token->__TOKENIZER__on_char($t)}push@heredoc,$line}$token->{_terminator_line}=undef;if (@heredoc and defined$heredoc[-1]){if ($t->{source_eof_chop}){chop$heredoc[-1];$t->{source_eof_chop}=''}$token->{_terminator_line}=pop@heredoc if$self->_is_terminator($token->{_terminator},$heredoc[-1],$token->{_indented})}if ($token->{_indented}&& $token->{_terminator_line}){my$indent=$self->_indent($token);$token->{_indentation}=$indent;if ($self->_is_match_indent($token,$indent)){s/^$indent// for@heredoc}s/^$indent// for$token->{_terminator_line}}$token->{_damaged}=1;$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_HEREDOC

$fatpacked{"PPI/Token/Label.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_LABEL';
  package PPI::Token::Label;use strict;use PPI::Token ();our$VERSION='1.271';our@ISA="PPI::Token";1;
PPI_TOKEN_LABEL

$fatpacked{"PPI/Token/Magic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_MAGIC';
  package PPI::Token::Magic;use strict;use PPI::Token::Symbol ();use PPI::Token::Unknown ();use PPI::Singletons qw'%MAGIC $CURLY_SYMBOL';our$VERSION='1.271';our@ISA="PPI::Token::Symbol";sub __TOKENIZER__on_char {my$t=$_[1];my$c=$t->{token}->{content}.substr($t->{line},$t->{line_cursor},1);if ($c =~ /^  \$  .*  [  \w  :  \$  \{  ]  $/x){if ($c =~ /^(\$(?:\_[\w:]|::))/ or $c =~ /^\$\'[\w]/){if ($c =~ /^\$\'\d$/){return$t->_finalize_token->__TOKENIZER__on_char($t)}$t->{class}=$t->{token}->set_class('Symbol');return PPI::Token::Symbol->__TOKENIZER__on_char($t)}if ($c =~ /^\$\$\w/){$t->{token}=PPI::Token::Cast->new('$');$t->_finalize_token;return$t->_new_token('Symbol','$')}if ($c eq '$${'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{token}=PPI::Token::Cast->new('$');$t->_finalize_token;return$t->_new_token('Magic','$')}}if ($c eq '$#$' or $c eq '$#{'){$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($c =~ /^(\$\#)\w/){$t->{token}=PPI::Token::ArrayIndex->new("$1");return PPI::Token::ArrayIndex->__TOKENIZER__on_char($t)}if ($c =~ /^\$\^\w+$/o){my$next=substr($t->{line},$t->{line_cursor}+1,1);if ($MAGIC{$c}&& (!$next || $next !~ /\w/)){$t->{token}->{content}=$c;$t->{line_cursor}++}else {return 1}}if ($c =~ /^\$\#\{/){$t->{token}=PPI::Token::Cast->new('$#');$t->_finalize_token;return$t->_new_token('Structure','{')}}elsif ($c =~ /^%\^/){return 1 if$c eq '%^';if ($MAGIC{$c}){$t->{token}->{content}=$c;$t->{line_cursor}++}else {chop$t->{token}->{content};bless$t->{token},$t->{class}='PPI::Token::Operator';$t->{line_cursor}--}}if ($MAGIC{$c}){$t->{line_cursor}+= length($c)- length($t->{token}->{content});$t->{token}->{content}=$c}else {pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/($CURLY_SYMBOL)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}elsif ($c =~ /^\$\d+$/ and $t->{line}=~ /\G(\d+)/gc){$t->{token}{content}.= $1;$t->{line_cursor}+= length $1}}$t->_finalize_token->__TOKENIZER__on_char($t)}sub canonical {$_[0]->content}1;
PPI_TOKEN_MAGIC

$fatpacked{"PPI/Token/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER';
  package PPI::Token::Number;use strict;use PPI::Token ();our$VERSION='1.271';our@ISA="PPI::Token";sub base() {10}sub literal {return 0 + $_[0]->_literal}sub _literal {my$self=shift;my$string=$self->content;$string =~ s/^\+//;$string =~ s/_//g;return$string}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';my$token=$t->{token};if ($token->{content}=~ /^-?0_*$/){if ($char eq 'x' || $char eq 'X'){$t->{class}=$t->{token}->set_class('Number::Hex');return 1}elsif ($char eq 'b' || $char eq 'B'){$t->{class}=$t->{token}->set_class('Number::Binary');return 1}elsif ($char =~ /\d/){if ($char eq '8' or $char eq '9'){$token->{_error}="Illegal character in octal number '$char'"}$t->{class}=$t->{token}->set_class('Number::Octal');return 1}}return 1 if$char =~ /\d/o;if ($char eq '.'){$t->{class}=$t->{token}->set_class('Number::Float');return 1}if ($char eq 'e' || $char eq 'E'){$t->{class}=$t->{token}->set_class('Number::Exp');return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER

$fatpacked{"PPI/Token/Number/Binary.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_BINARY';
  package PPI::Token::Number::Binary;use strict;use PPI::Token::Number ();our$VERSION='1.271';our@ISA="PPI::Token::Number";sub base() {2}sub literal {my$self=shift;return if$self->{_error};my$str=$self->_literal;my$neg=$str =~ s/^\-//;$str =~ s/^0[bB]//;my$val=0;for my$bit ($str =~ m/(.)/g){$val=$val * 2 + $bit}return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';if ($char =~ /[\w\d]/){unless ($char eq '1' or $char eq '0'){$t->{token}->{_error}="Illegal character in binary number '$char'"}return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_BINARY

$fatpacked{"PPI/Token/Number/Exp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_EXP';
  package PPI::Token::Number::Exp;use strict;use PPI::Token::Number::Float ();our$VERSION='1.271';our@ISA="PPI::Token::Number::Float";sub literal {my$self=shift;return if$self->{_error};my ($mantissa,$exponent)=split m/e/i,$self->_literal;my$neg=$mantissa =~ s/^\-//;$mantissa =~ s/^\./0./;$exponent =~ s/^\+//;$exponent += 0;my$negpow=0;if ($exponent < 0){$negpow=1;$exponent *= -1}my$result=1;my$power=10;for (my$bit=1;$exponent;$bit=$bit << 1){if ($exponent & $bit){$exponent=$exponent ^ $bit;$result *= $power}$power *= $power}my$val=$neg ? 0 - $mantissa : $mantissa;return$negpow ? $val / $result : $val * $result}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';return 1 if$char =~ /\d/o;if ($t->{token}->{content}=~ /e$/i){return 1 if$char eq '-' || $char eq '+';if ($t->{token}->{content}=~ s/\.(e)$//i){my$word=$1;$t->{class}=$t->{token}->set_class('Number');$t->_new_token('Operator','.');$t->_new_token('Word',$word);return$t->{class}->__TOKENIZER__on_char($t)}else {$t->{token}->{_error}="Illegal character in exponent '$char'"}}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_EXP

$fatpacked{"PPI/Token/Number/Float.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_FLOAT';
  package PPI::Token::Number::Float;use strict;use PPI::Token::Number ();our$VERSION='1.271';our@ISA="PPI::Token::Number";sub base() {10}sub literal {my$self=shift;my$str=$self->_literal;my$neg=$str =~ s/^\-//;$str =~ s/^\./0./;my$val=0+$str;return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';return 1 if$char =~ /\d/o;if ($char eq '.'){if ($t->{token}{content}=~ /\.$/){chop$t->{token}{content};$t->{class}=$t->{token}->set_class('Number');$t->_new_token('Operator','..');return 0}elsif ($t->{token}{content}=~ /\._/){($t->{token}{content},my$bareword)=split /\./,$t->{token}{content};$t->{class}=$t->{token}->set_class('Number');$t->_new_token('Operator','.');$t->_new_token('Word',$bareword);$t->_new_token('Operator','.');return 0}else {$t->{class}=$t->{token}->set_class('Number::Version');return 1}}my$char2=substr$t->{line},$t->{line_cursor}+1,1;if ("$char$char2" =~ /[eE][0-9+-]/){$t->{class}=$t->{token}->set_class('Number::Exp');return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_FLOAT

$fatpacked{"PPI/Token/Number/Hex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_HEX';
  package PPI::Token::Number::Hex;use strict;use PPI::Token::Number ();our$VERSION='1.271';our@ISA="PPI::Token::Number";sub base() {16}sub literal {my$self=shift;my$str=$self->_literal;my$neg=$str =~ s/^\-//;my$val=hex lc($str);return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';if ($char =~ /[[:xdigit:]]/){return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_HEX

$fatpacked{"PPI/Token/Number/Octal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_OCTAL';
  package PPI::Token::Number::Octal;use strict;use PPI::Token::Number ();our$VERSION='1.271';our@ISA="PPI::Token::Number";sub base() {8}sub literal {my$self=shift;return if$self->{_error};my$str=$self->_literal;my$neg=$str =~ s/^\-//;my$val=oct$str;return$neg ? -$val : $val}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char eq '_';if ($char =~ /\d/){if ($char eq '8' or $char eq '9'){$t->{token}->{_error}="Illegal character in octal number '$char'"}return 1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_OCTAL

$fatpacked{"PPI/Token/Number/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_VERSION';
  package PPI::Token::Number::Version;use strict;use PPI::Token::Number ();our$VERSION='1.271';our@ISA="PPI::Token::Number";sub base() {256}sub literal {my$self=shift;my$content=$self->{content};$content =~ s/^v//;return join '',map {chr $_}(split /\./,$content)}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;my$char=substr($t->{line},$t->{line_cursor},1);return 1 if$char =~ /\d/o;if($char eq '_'){return 1 if$t->{token}{content}!~ /\.$/;chop$t->{token}->{content};$t->{class}=$t->{token}->set_class('Number::Float')if$t->{token}{content}!~ /\..+\./;$t->_new_token('Operator','.');$t->_new_token('Word','_');return 0}if ($char eq '.'){if ($t->{token}->{content}=~ /\.$/){chop$t->{token}->{content};$t->{class}=$t->{token}->set_class('Number::Float')if$t->{token}{content}!~ /\..+\./;$t->_new_token('Operator','..');return 0}else {return 1}}$t->_finalize_token->__TOKENIZER__on_char($t)}sub __TOKENIZER__commit {my$t=$_[1];pos$t->{line}=$t->{line_cursor};return PPI::Token::Word->__TOKENIZER__commit($t)if$t->{line}!~ m/\G(v\d[_\d]*(?:\.\d[_\d]*)+|v\d[_\d]*\b)/gc;my$content=$1;return PPI::Token::Word->__TOKENIZER__commit($t)if$content !~ /\./ and $t->__current_token_is_forced_word($content);$t->{line_cursor}+= length$content;$t->_new_token('Number::Version',$content);$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_NUMBER_VERSION

$fatpacked{"PPI/Token/Operator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_OPERATOR';
  package PPI::Token::Operator;use strict;use PPI::Token ();use PPI::Singletons '%OPERATOR';our$VERSION='1.271';our@ISA="PPI::Token";sub __TOKENIZER__on_char {my$t=$_[1];my$char=substr($t->{line},$t->{line_cursor},1);my$content=$t->{token}->{content};if(length($content)< 4 && $content .substr($t->{line},$t->{line_cursor},4 - length($content))eq '<<>>'){return 1}return 1 if$OPERATOR{$content .$char };if ($content eq '.'){if ($char =~ /^[0-9]$/){$t->{class}=$t->{token}->set_class('Number::Float');return$t->{class}->__TOKENIZER__on_char($t)}}if ($content eq '<<'){pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G ~? (?: (?!\d)\w | \s*['"`] | \\\w ) /gcx){$t->{class}=$t->{token}->set_class('HereDoc');return$t->{class}->__TOKENIZER__on_char($t)}}$t->{class}=$t->{token}->set_class('QuoteLike::Readline')if$content eq '<>' or $content eq '<<>>';$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_OPERATOR

$fatpacked{"PPI/Token/Pod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_POD';
  package PPI::Token::Pod;use strict;use Params::Util qw{_INSTANCE};use PPI::Token ();our$VERSION='1.271';our@ISA="PPI::Token";sub merge {my$class=(!ref $_[0])? shift : return undef;if (grep {!_INSTANCE($_,'PPI::Token::Pod')}@_){return undef}my@content=(map {[$_->lines ]}@_)or return undef;for my$pod (@content){if (@$pod and $pod->[0]=~ /^=pod\b/o){shift @$pod}if (@$pod and $pod->[-1]=~ /^=cut\b/o){pop @$pod}while (@$pod and $pod->[0]eq ''){shift @$pod}while (@$pod and $pod->[-1]eq ''){pop @$pod}}@content=(['=pod' ],grep {@$_}@content,['=cut' ]);$class->new(join "\n",map {join("\n",@$_)."\n"}@content)}sub lines {split /(?:\015{1,2}\012|\015|\012)/,$_[0]->{content}}sub significant() {''}sub __TOKENIZER__on_line_start {my$t=$_[1];$t->{token}->{content}.= $t->{line};if ($t->{line}=~ /^=(\w+)/){$t->_finalize_token if $1 eq 'cut'}0}1;
PPI_TOKEN_POD

$fatpacked{"PPI/Token/Prototype.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_PROTOTYPE';
  package PPI::Token::Prototype;use strict;use PPI::Token ();our$VERSION='1.271';our@ISA="PPI::Token";sub __TOKENIZER__on_char {my$class=shift;my$t=shift;pos$t->{line}=$t->{line_cursor};die "regex should always match" if$t->{line}!~ m/\G(.*?\n?(?:\)|$))/gc;$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1;return 0 unless $1 =~ /\)$/;$t->_finalize_token->__TOKENIZER__on_char($t)}sub prototype {my$self=shift;my$proto=$self->content;$proto =~ s/(^\(|\)$|\s+)//g;$proto}1;
PPI_TOKEN_PROTOTYPE

$fatpacked{"PPI/Token/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE';
  package PPI::Token::Quote;use strict;use PPI::Token ();our$VERSION='1.271';our@ISA="PPI::Token";1;
PPI_TOKEN_QUOTE

$fatpacked{"PPI/Token/Quote/Double.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_DOUBLE';
  package PPI::Token::Quote::Double;use strict;use Params::Util qw{_INSTANCE};use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Simple ();our$VERSION='1.271';our@ISA=qw{PPI::Token::_QuoteEngine::Simple PPI::Token::Quote};sub interpolations {!!($_[0]->content =~ /(?<!\\)(?:\\\\)*[\$\@]/)}sub simplify {my$self=_INSTANCE(shift,'PPI::Token::Quote::Double')or return undef;my$content=$self->content;my$value=substr($content,1,length($content)- 2);return$self if$value =~ /[\\\$@\'\"]/;$self->{content}="'$value'";bless$self,'PPI::Token::Quote::Single'}sub string {my$str=$_[0]->{content};substr($str,1,length($str)- 2)}1;
PPI_TOKEN_QUOTE_DOUBLE

$fatpacked{"PPI/Token/Quote/Interpolate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_INTERPOLATE';
  package PPI::Token::Quote::Interpolate;use strict;use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.271';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Quote};sub string {my$self=shift;my@sections=$self->_sections;my$str=$sections[0];substr($self->{content},$str->{position},$str->{size})}1;
PPI_TOKEN_QUOTE_INTERPOLATE

$fatpacked{"PPI/Token/Quote/Literal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_LITERAL';
  package PPI::Token::Quote::Literal;use strict;use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.271';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Quote};sub string {my$self=shift;my@sections=$self->_sections;my$str=$sections[0];substr($self->{content},$str->{position},$str->{size})}*literal=*PPI::Token::Quote::Single::literal;1;
PPI_TOKEN_QUOTE_LITERAL

$fatpacked{"PPI/Token/Quote/Single.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_SINGLE';
  package PPI::Token::Quote::Single;use strict;use PPI::Token::Quote ();use PPI::Token::_QuoteEngine::Simple ();our$VERSION='1.271';our@ISA=qw{PPI::Token::_QuoteEngine::Simple PPI::Token::Quote};sub string {my$str=$_[0]->{content};substr($str,1,length($str)- 2)}my%UNESCAPE=("\\'"=>"'","\\\\"=>"\\",);sub literal {my$str=$_[0]->string;$str =~ s/(\\.)/$UNESCAPE{$1} || $1/ge;return$str}1;
PPI_TOKEN_QUOTE_SINGLE

$fatpacked{"PPI/Token/QuoteLike.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE';
  package PPI::Token::QuoteLike;use strict;use PPI::Token ();our$VERSION='1.271';our@ISA="PPI::Token";1;
PPI_TOKEN_QUOTELIKE

$fatpacked{"PPI/Token/QuoteLike/Backtick.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_BACKTICK';
  package PPI::Token::QuoteLike::Backtick;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Simple ();our$VERSION='1.271';our@ISA=qw{PPI::Token::_QuoteEngine::Simple PPI::Token::QuoteLike};1;
PPI_TOKEN_QUOTELIKE_BACKTICK

$fatpacked{"PPI/Token/QuoteLike/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_COMMAND';
  package PPI::Token::QuoteLike::Command;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.271';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike};1;
PPI_TOKEN_QUOTELIKE_COMMAND

$fatpacked{"PPI/Token/QuoteLike/Readline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_READLINE';
  package PPI::Token::QuoteLike::Readline;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.271';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike};1;
PPI_TOKEN_QUOTELIKE_READLINE

$fatpacked{"PPI/Token/QuoteLike/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_REGEXP';
  package PPI::Token::QuoteLike::Regexp;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.271';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike};sub get_match_string {return $_[0]->_section_content(0)}sub get_substitute_string {return undef}sub get_modifiers {return $_[0]->_modifiers()}sub get_delimiters {return $_[0]->_delimiters()}1;
PPI_TOKEN_QUOTELIKE_REGEXP

$fatpacked{"PPI/Token/QuoteLike/Words.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_WORDS';
  package PPI::Token::QuoteLike::Words;use strict;use PPI::Token::QuoteLike ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.271';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::QuoteLike};sub literal {my ($self)=@_;my$content=$self->_section_content(0);return if!defined$content;my ($left,$right)=($self->_delimiters,'','');$content =~ s/\\([\Q$left$right\\\E])/$1/g;my@words=split ' ',$content;return@words}1;
PPI_TOKEN_QUOTELIKE_WORDS

$fatpacked{"PPI/Token/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP';
  package PPI::Token::Regexp;use strict;use PPI::Token ();our$VERSION='1.271';our@ISA="PPI::Token";sub get_match_string {return $_[0]->_section_content(0)}sub get_substitute_string {return $_[0]->_section_content(1)}sub get_modifiers {return $_[0]->_modifiers()}sub get_delimiters {return $_[0]->_delimiters()}1;
PPI_TOKEN_REGEXP

$fatpacked{"PPI/Token/Regexp/Match.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_MATCH';
  package PPI::Token::Regexp::Match;use strict;use PPI::Token::Regexp ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.271';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Regexp};1;
PPI_TOKEN_REGEXP_MATCH

$fatpacked{"PPI/Token/Regexp/Substitute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_SUBSTITUTE';
  package PPI::Token::Regexp::Substitute;use strict;use PPI::Token::Regexp ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.271';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Regexp};1;
PPI_TOKEN_REGEXP_SUBSTITUTE

$fatpacked{"PPI/Token/Regexp/Transliterate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_TRANSLITERATE';
  package PPI::Token::Regexp::Transliterate;use strict;use PPI::Token::Regexp ();use PPI::Token::_QuoteEngine::Full ();our$VERSION='1.271';our@ISA=qw{PPI::Token::_QuoteEngine::Full PPI::Token::Regexp};1;
PPI_TOKEN_REGEXP_TRANSLITERATE

$fatpacked{"PPI/Token/Separator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_SEPARATOR';
  package PPI::Token::Separator;use strict;use PPI::Token::Word ();our$VERSION='1.271';our@ISA="PPI::Token::Word";1;
PPI_TOKEN_SEPARATOR

$fatpacked{"PPI/Token/Structure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_STRUCTURE';
  package PPI::Token::Structure;use strict;use PPI::Token ();our$VERSION='1.271';our@ISA="PPI::Token";my%MATCH=(ord '{'=>'}',ord '}'=>'{',ord '['=>']',ord ']'=>'[',ord '('=>')',ord ')'=>'(',);my%OPENS=(ord '{'=>1,ord '['=>1,ord '('=>1,);my%CLOSES=(ord '}'=>1,ord ']'=>1,ord ')'=>1,);sub __TOKENIZER__on_char {$_[1]->_finalize_token->__TOKENIZER__on_char($_[1])}sub __TOKENIZER__commit {my$t=$_[1];$t->_new_token('Structure',substr($t->{line},$t->{line_cursor},1));$t->_finalize_token;0}sub __LEXER__opposite {$MATCH{ord $_[0]->{content}}}sub next_sibling {return $_[0]->SUPER::next_sibling if $_[0]->{content}eq ';';return ''}sub snext_sibling {return $_[0]->SUPER::snext_sibling if $_[0]->{content}eq ';';return ''}sub previous_sibling {return $_[0]->SUPER::previous_sibling if $_[0]->{content}eq ';';return ''}sub sprevious_sibling {return $_[0]->SUPER::sprevious_sibling if $_[0]->{content}eq ';';return ''}sub next_token {my$self=shift;return$self->SUPER::next_token if$self->{content}eq ';';my$structure=$self->parent or return '';if ($OPENS{ord$self->{content}}){my$child=$structure->child(0);if ($child){return$child->isa('PPI::Token')? $child : $child->first_token}elsif ($structure->finish){return$structure->finish}}$structure->next_token}sub previous_token {my$self=shift;return$self->SUPER::previous_token if$self->{content}eq ';';my$structure=$self->parent or return '';if ($CLOSES{ord$self->{content}}){my$child=$structure->child(-1);if ($child){return$child->isa('PPI::Token')? $child : $child->last_token}elsif ($structure->start){return$structure->start}}$structure->previous_token}1;
PPI_TOKEN_STRUCTURE

$fatpacked{"PPI/Token/Symbol.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_SYMBOL';
  package PPI::Token::Symbol;use strict;use Params::Util qw{_INSTANCE};use PPI::Token ();our$VERSION='1.271';our@ISA="PPI::Token";sub canonical {my$symbol=shift->content;$symbol =~ s/\s+//;$symbol =~ s/\'/::/g;$symbol =~ s/(?<=[\$\@\%\&\*])::/main::/;$symbol}my%cast_which_trumps_braces=map {$_=>1}qw{$ @ %};sub symbol {my$self=shift;my$symbol=$self->canonical;my$type=substr($symbol,0,1);return$symbol if$type eq '&';my$after=$self->snext_sibling;return$symbol unless _INSTANCE($after,'PPI::Structure');my$braces=$after->braces;return$symbol unless defined$braces;if ($type eq '$'){my$before=$self->sprevious_sibling;return$symbol if$before && $before->isa('PPI::Token::Cast')&& $cast_which_trumps_braces{$before->content };substr($symbol,0,1,'@')if$braces eq '[]';substr($symbol,0,1,'%')if$braces eq '{}'}elsif ($type eq '@'){substr($symbol,0,1,'%')if$braces eq '{}'}elsif ($type eq '%'){substr($symbol,0,1,'@')if$braces eq '[]'}$symbol}sub raw_type {substr($_[0]->content,0,1)}sub symbol_type {substr($_[0]->symbol,0,1)}sub __TOKENIZER__on_char {my$t=$_[1];pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G([\w:\']+)/gc){$t->{token}->{content}.= $1;$t->{line_cursor}+= length $1}my$content=$t->{token}->{content};if ($content eq '@_' or $content eq '$_'){$t->{class}=$t->{token}->set_class('Magic');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($content eq '$::'){my$nextchar=substr($t->{line},$t->{line_cursor},1);if ($nextchar eq '|'){$t->{token}->{content}.= $nextchar;$t->{line_cursor}++;$t->{class}=$t->{token}->set_class('Magic')}return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($content =~ /^[\$%*@&]::(?:[^\w]|$)/){my$current=substr($content,0,3,'');$t->{token}->{content}=$current;$t->{line_cursor}-= length($content);return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($content =~ /^(?:\$|\@)\d+/){$t->{class}=$t->{token}->set_class('Magic');return$t->_finalize_token->__TOKENIZER__on_char($t)}$content =~ /^(
  		[\$@%&*]
  		(?: : (?!:) | # Allow single-colon non-magic variables
  			(?: \w+ | \' (?!\d) \w+ | \:: \w+ )
  			(?:
  				# Allow both :: and ' in namespace separators
  				(?: \' (?!\d) \w+ | \:: \w+ )
  			)*
  			(?: :: )? # Technically a compiler-magic hash, but keep it here
  		)
  	)/x or return undef;unless (length $1 eq length$content){$t->{line_cursor}+= length($1)- length($content);$t->{token}->{content}=$1}$t->_finalize_token->__TOKENIZER__on_char($t)}1;
PPI_TOKEN_SYMBOL

$fatpacked{"PPI/Token/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_UNKNOWN';
  package PPI::Token::Unknown;use strict;use PPI::Token ();use PPI::Exception ();use PPI::Singletons qw'%MAGIC $CURLY_SYMBOL';our$VERSION='1.271';our@ISA="PPI::Token";sub __TOKENIZER__on_char {my ($self,$t)=@_;my$c=$t->{token}->{content};my$char=substr($t->{line},$t->{line_cursor},1);if ($c eq '*'){if ($char =~ /\d/){$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($char =~ /[\w:]/){my ($prev)=$t->_previous_significant_tokens(1);if (not $prev or not $prev->isa('PPI::Token::Number')){$t->{class}=$t->{token}->set_class('Symbol');return 1}}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}}if ($char eq '*'){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){$t->{class}=$t->{token}->set_class('Cast');return 1}}if ($char eq '*' || $char eq '='){$t->{class}=$t->{token}->set_class('Operator');return 1}return$self->_as_cast_or_op($t)if$self->_is_cast_or_op($char);$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}elsif ($c eq '$'){if ($char eq '*' || $char eq '#'){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){$t->{class}=$t->{token}->set_class('Cast');return 1}}if ($char =~ /[a-z_]/i){$t->{class}=$t->{token}->set_class('Symbol');return 1}if ($MAGIC{$c .$char }){$t->{class}=$t->{token}->set_class('Magic');return 1}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}}$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}elsif ($c eq '@'){if ($char eq '*'){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){$t->{class}=$t->{token}->set_class('Cast');return 1}}if ($char =~ /[\w:]/){$t->{class}=$t->{token}->set_class('Symbol');return 1}if ($MAGIC{$c .$char }){$t->{class}=$t->{token}->set_class('Magic');return 1}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}}$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}elsif ($c eq '%'){if ($char eq '*' || $char eq '['){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){if ($char eq '*'){$t->{class}=$t->{token}->set_class('Cast');return 1}if ($char eq '['){$t->{class}=$t->{token}->set_class('Cast');return$t->_finalize_token->__TOKENIZER__on_char($t)}}}if ($char =~ /\d/){$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($char eq '^' || $MAGIC{$c .$char }){$t->{class}=$t->{token}->set_class('Magic');return 1}if ($char =~ /[\w:]/){my ($prev)=$t->_previous_significant_tokens(1);if (not $prev or not $prev->isa('PPI::Token::Number')){$t->{class}=$t->{token}->set_class('Symbol');return 1}}if ($char eq '{'){pos$t->{line}=$t->{line_cursor}+ 1;if ($t->{line}=~ m/$CURLY_SYMBOL/gc){$t->{class}=$t->{token}->set_class('Magic');return 1}}return$self->_as_cast_or_op($t)if$self->_is_cast_or_op($char);$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}elsif ($c eq '&'){if ($char eq '*'){my ($prev)=$t->_previous_significant_tokens(1);if ($prev and $prev->isa('PPI::Token::Operator')and $prev->content eq '->'){$t->{class}=$t->{token}->set_class('Cast');return 1}}if ($char =~ /\d/){$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}if ($char =~ /[\w:]/){my ($prev)=$t->_previous_significant_tokens(1);if (not $prev or not $prev->isa('PPI::Token::Number')){$t->{class}=$t->{token}->set_class('Symbol');return 1}}return$self->_as_cast_or_op($t)if$self->_is_cast_or_op($char);$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}elsif ($c eq '-'){if ($char =~ /\d/o){$t->{class}=$t->{token}->set_class('Number');return 1}if ($char eq '.'){$t->{class}=$t->{token}->set_class('Number::Float');return 1}if ($char =~ /[a-zA-Z]/){$t->{class}=$t->{token}->set_class('DashedWord');return 1}$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}elsif ($c eq ':'){if ($char eq ':'){$t->{class}=$t->{token}->set_class('Word');return 1}if ($self->__TOKENIZER__is_an_attribute($t)){$t->{class}=$t->{token}->set_class('Operator');$t->{token}->{_attribute}=1;return$t->_finalize_token->__TOKENIZER__on_char($t)}$t->{class}=$t->{token}->set_class('Operator');return$t->{class}->__TOKENIZER__on_char($t)}PPI::Exception->throw('Unknown value in PPI::Token::Unknown token')}sub _is_cast_or_op {my ($self,$char)=@_;return 1 if$char eq '$';return 1 if$char eq '@';return 1 if$char eq '%';return 1 if$char eq '*';return 1 if$char eq '{';return}sub _as_cast_or_op {my ($self,$t)=@_;my$class=_cast_or_op($t);$t->{class}=$t->{token}->set_class($class);return$t->_finalize_token->__TOKENIZER__on_char($t)}sub _prev_significant_w_cursor {my ($tokens,$cursor,$extra_check)=@_;while ($cursor >= 0){my$token=$tokens->[$cursor-- ];next if!$token->significant;next if$extra_check and!$extra_check->($token);return ($token,$cursor)}return (undef,$cursor)}sub _cast_or_op {my ($t)=@_;my$tokens=$t->{tokens};my$cursor=scalar(@$tokens)- 1;my$token;($token,$cursor)=_prev_significant_w_cursor($tokens,$cursor);return 'Cast' if!$token;if ($token->isa('PPI::Token::Structure')and $token->content eq '}'){my$structure_depth=1;($token,$cursor)=_prev_significant_w_cursor($tokens,$cursor,sub {my ($token)=@_;return if!$token->isa('PPI::Token::Structure');if ($token eq '}'){$structure_depth++;return}if ($token eq '{'){$structure_depth--;return if$structure_depth}return 1});return 'Operator' if!$token;($token,$cursor)=_prev_significant_w_cursor($tokens,$cursor);return 'Operator' if!$token;return 'Operator' if$token->isa('PPI::Token::Symbol');my%meth_or_subscript_end=map {$_=>1}qw@-> } ]@;return 'Operator' if$meth_or_subscript_end{$token->content };my$content=$token->content;my$produces_or_wants_value=($token->isa('PPI::Token::Word')and ($content eq 'do' or $content eq 'eval'));return$produces_or_wants_value ? 'Operator' : 'Cast'}my%list_start_or_term_end=map {$_=>1}qw@; ( { [@;return 'Cast' if$token->isa('PPI::Token::Structure')and $list_start_or_term_end{$token->content }or $token->isa('PPI::Token::Cast')or $token->isa('PPI::Token::Operator')or $token->isa('PPI::Token::Label');return 'Operator' if!$token->isa('PPI::Token::Word');($token,$cursor)=_prev_significant_w_cursor($tokens,$cursor);return 'Cast' if!$token || $token->content ne '->';return 'Operator'}sub __TOKENIZER__is_an_attribute {my$t=$_[1];my@tokens=$t->_previous_significant_tokens(3);my$p0=$tokens[0];return '' if not $p0;return 1 if$p0->isa('PPI::Token::Attribute');return 1 if$p0->isa('PPI::Token::Prototype');return '' unless$p0->isa('PPI::Token::Word');if ($p0->isa('PPI::Token::Word')and $p0->content eq 'sub'){return 1}my$p1=$tokens[1];my$p2=$tokens[2];if ($p1 and $p1->isa('PPI::Token::Word')and $p1->content eq 'sub' and (not $p2 or $p2->isa('PPI::Token::Structure')or ($p2->isa('PPI::Token::Whitespace')and $p2->content eq ''))){return 1}''}1;
PPI_TOKEN_UNKNOWN

$fatpacked{"PPI/Token/Whitespace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_WHITESPACE';
  package PPI::Token::Whitespace;use strict;use Clone ();use PPI::Token ();our$VERSION='1.271';our@ISA="PPI::Token";my$null;sub null {$null ||= $_[0]->new('');Clone::clone($null)}sub significant() {''}sub tidy {$_[0]->{content}=~ s/^\s+?(?>\n)//;1}my%COMMITMAP=(map({ord $_=>'PPI::Token::Word'}'a' .. 'u','A' .. 'Z',qw"w y z _"),map({ord $_=>'PPI::Token::Structure'}qw"; [ ] { } )"),ord '#'=>'PPI::Token::Comment',ord 'v'=>'PPI::Token::Number::Version',);my%CLASSMAP=(map({ord $_=>'Number'}0 .. 9),map({ord $_=>'Operator'}qw"= ? | + > . ! ~ ^"),map({ord $_=>'Unknown'}qw"* $ @ & : %"),ord ','=>'PPI::Token::Operator',ord "'"=>'Quote::Single',ord '"'=>'Quote::Double',ord '`'=>'QuoteLike::Backtick',ord '\\'=>'Cast',ord '_'=>'Word',9=>'Whitespace',10=>'Whitespace',12=>'Whitespace',13=>'Whitespace',32=>'Whitespace',);my%MATCHWORD=map {$_=>1}qw{return split if unless grep map};sub __TOKENIZER__on_line_start {my$t=$_[1];my$line=$t->{line};if ($line =~ /^\s*$/){$t->_new_token('Whitespace',$line);return 0}elsif ($line =~ /^\s*#/){$t->_new_token('Comment',$line);$t->_finalize_token;return 0}elsif ($line =~ /^=(\w+)/){$t->_new_token('Pod',$line);if ($1 eq 'cut'){}else {$t->{class}='PPI::Token::Pod'}return 0}elsif ($line =~ /^use v6\-alpha\;/){my@perl6;while (1){my$line6=$t->_get_line;last unless defined$line6;push@perl6,$line6}push @{$t->{perl6}},join '',@perl6;return 1}1}sub __TOKENIZER__on_char {my$t=$_[1];my$c=substr$t->{line},$t->{line_cursor},1;my$char=ord$c;return$COMMITMAP{$char}->__TOKENIZER__commit($t)if$COMMITMAP{$char};return$CLASSMAP{$char}if$CLASSMAP{$char};if ($char==40){$t->_finalize_token if$t->{token};my@tokens=$t->_previous_significant_tokens(3);my$p1=$tokens[1];my$p2=$tokens[2];if ($tokens[0]and $tokens[0]->isa('PPI::Token::Word')and $p1 and $p1->isa('PPI::Token::Word')and $p1->content eq 'sub' and (not $p2 or $p2->isa('PPI::Token::Structure')or ($p2->isa('PPI::Token::Whitespace')and $p2->content eq '')or ($p2->isa('PPI::Token::Word')and $p2->content =~ /^(?:my|our|state)$/))){return 'Prototype'}my$p0=$tokens[0];if ($p0 and $p0->isa('PPI::Token::Word')and $p0->content eq 'sub' and not ($p1 and $p1->isa('PPI::Token::Operator')and $p1->content eq '->')){return 'Prototype'}return 'Structure'}elsif ($char==60){$t->_finalize_token if$t->{token};my$prev=$t->_last_significant_token;return 'Operator' if$prev and $prev->isa('PPI::Token::Symbol');return 'Operator' if$prev and $prev->isa('PPI::Token::Magic');return 'Operator' if$prev and $prev->isa('PPI::Token::Number');return 'Operator' if$prev and $prev->isa('PPI::Token::ArrayIndex');my$next_char=substr($t->{line},$t->{line_cursor}+ 1,2);return 'Operator' if$next_char =~ /<[^>]/;return 'Operator' if not $prev;my$prec=$prev->content;return 'QuoteLike::Readline' if ($prev->isa('PPI::Token::Structure')and $prec eq '(')or ($prev->isa('PPI::Token::Structure')and $prec eq ';')or ($prev->isa('PPI::Token::Word')and $prec eq 'while')or ($prev->isa('PPI::Token::Operator')and $prec eq '=')or ($prev->isa('PPI::Token::Operator')and $prec eq ',');if ($prev->isa('PPI::Token::Structure')and $prec eq '}'){pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G<(?!\d)\w+>/gc){return 'QuoteLike::Readline'}}return 'Operator'}elsif ($char==47){$t->_finalize_token if$t->{token};my$prev=$t->_last_significant_token;return 'Regexp::Match' if not $prev;my$prec=$prev->content;return 'Regexp::Match' if$prev->isa('PPI::Token::Operator');return 'Operator' if$prev->isa('PPI::Token::Symbol');if ($prec eq ']' and $prev->isa('PPI::Token::Structure')){return 'Operator'}return 'Operator' if$prev->isa('PPI::Token::Number');if ($prev->isa('PPI::Token::Structure')and ($prec eq '(' or $prec eq '{' or $prec eq ';')){return 'Regexp::Match'}if ($MATCHWORD{$prec}and $prev->isa('PPI::Token::Word')){return 'Regexp::Match'}my$next_char=substr$t->{line},$t->{line_cursor}+ 1,1;if (defined$next_char and length$next_char){if ($next_char =~ /(?:\^|\[|\\)/){return 'Regexp::Match'}}return 'Operator'}elsif ($char==120){if ($t->_current_x_is_operator){pos$t->{line}=$t->{line_cursor}+ 1;return 'Operator' if$t->{line}=~ m/\G(?:
  				\d  # x op with no whitespace e.g. 'x3'
  				|
  				(?!(  # negative lookahead
  					=>  # not on left of fat comma
  					|
  					\w  # not a word like "xyzzy"
  					|
  					\s  # not x op plus whitespace
  				))
  			)/gcx}return PPI::Token::Word->__TOKENIZER__commit($t)}elsif ($char==45){my$context=$t->_opcontext;if ($context eq 'operator'){return 'Operator'}else {return 'Unknown'}}elsif ($char >= 128){return 'PPI::Token::Word'->__TOKENIZER__commit($t)if$c =~ /\w/;return 'Whitespace' if$c =~ /\s/}PPI::Exception->throw("Encountered unexpected character '$char'")}sub __TOKENIZER__on_line_end {$_[1]->_finalize_token if $_[1]->{token}}1;
PPI_TOKEN_WHITESPACE

$fatpacked{"PPI/Token/Word.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_WORD';
  package PPI::Token::Word;use strict;use PPI::Token ();use PPI::Singletons qw'%OPERATOR %QUOTELIKE %KEYWORDS';our$VERSION='1.271';our@ISA="PPI::Token";sub literal {my$self=shift;my$word=$self->content;$word =~ s/\'/::/g;return$word}sub method_call {my$self=shift;my$previous=$self->sprevious_sibling;if ($previous and $previous->isa('PPI::Token::Operator')and $previous->content eq '->'){return 1}my$snext=$self->snext_sibling;return 0 unless$snext;if ($snext->isa('PPI::Structure::List')or $snext->isa('PPI::Token::Structure')or $snext->isa('PPI::Token::Operator')and ($snext->content eq ',' or $snext->content eq '=>')){return 0}if ($snext->isa('PPI::Token::Word')and $snext->content =~ m< \w :: \z >xms){return 1}return}sub __TOKENIZER__on_char {my$class=shift;my$t=shift;pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G(\w+(?:(?:\'|::)\w+)*(?:::)?)/gc){my$word=$1;if ($word =~ /^(\w+)'/ && $KEYWORDS{$1}){$word=$1}$t->{token}->{content}.= $word;$t->{line_cursor}+= length$word}if (__current_token_is_attribute($t)){$t->{class}=$t->{token}->set_class('Attribute');return$t->{class}->__TOKENIZER__commit($t)}my$word=$t->{token}->{content};if ($KEYWORDS{$word}){if ($t->__current_token_is_forced_word){$t->{class}=$t->{token}->set_class('Word');return$t->{class}->__TOKENIZER__on_char($t)}if ($QUOTELIKE{$word}){$t->{class}=$t->{token}->set_class($QUOTELIKE{$word});return$t->{class}->__TOKENIZER__on_char($t)}if ($OPERATOR{$word}){$t->{class}=$t->{token}->set_class('Operator');return$t->_finalize_token->__TOKENIZER__on_char($t)}}if ($word =~ /\:/){return$t->_finalize_token->__TOKENIZER__on_char($t)}my$char=substr($t->{line},$t->{line_cursor},1);if ($char eq ':'){$t->{token}->{content}.= ':';$t->{line_cursor}++;$t->{class}=$t->{token}->set_class('Label')}elsif ($word eq '_'){$t->{class}=$t->{token}->set_class('Magic')}$t->_finalize_token->__TOKENIZER__on_char($t)}sub __TOKENIZER__commit {my ($class,$t)=@_;pos$t->{line}=$t->{line_cursor};unless ($t->{line}=~ m/\G((?!\d)\w+(?:(?:\'|::)\w+)*(?:::)?)/gc){die sprintf "Fatal error... regex failed to match in '%s' when expected",substr$t->{line},$t->{line_cursor}}my$word=$1;if ($word =~ /^(\w+)'/ && $KEYWORDS{$1}){$word=$1}$t->{line_cursor}+= length$word;if (__current_token_is_attribute($t)){$t->_new_token('Attribute',$word);return ($t->{line_cursor}>= $t->{line_length})? 0 : $t->{class}->__TOKENIZER__on_char($t)}if ($word eq '__END__'){$t->_new_token('Separator',$1);$t->_finalize_token;$t->{zone}='PPI::Token::End';my$end_rest=substr($t->{line},$t->{line_cursor});$t->{line_cursor}=length$t->{line};if ($end_rest =~ /\n$/){chomp$end_rest;$t->_new_token('Comment',$end_rest)if length$end_rest;$t->_new_token('Whitespace',"\n")}else {$t->_new_token('Comment',$end_rest)if length$end_rest}$t->_finalize_token;return 0}if ($word eq '__DATA__'){$t->_new_token('Separator',"$1");$t->_finalize_token;$t->{zone}='PPI::Token::Data';my$data_rest=substr($t->{line},$t->{line_cursor});$t->{line_cursor}=length$t->{line};if ($data_rest =~ /\n$/){chomp$data_rest;$t->_new_token('Comment',$data_rest)if length$data_rest;$t->_new_token('Whitespace',"\n")}else {$t->_new_token('Comment',$data_rest)if length$data_rest}$t->_finalize_token;return 0}my$token_class;if ($word =~ /\:/){$token_class='Word'}elsif ($KEYWORDS{$word}and $t->__current_token_is_forced_word){$token_class='Word'}elsif ($QUOTELIKE{$word}){$t->_new_token($QUOTELIKE{$word},$word);return ($t->{line_cursor}>= $t->{line_length})? 0 : $t->{class}->__TOKENIZER__on_char($t)}elsif ($OPERATOR{$word}&& ($word ne 'x' || $t->_current_x_is_operator)){$token_class='Operator'}else {my@tokens=$t->_previous_significant_tokens(1);pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G(\s*:)(?!:)/gc){if ($tokens[0]and $tokens[0]->{content}eq 'sub'){$token_class='Word'}else {$word .= $1;$t->{line_cursor}+= length($1);$token_class='Label'}}elsif ($word eq '_'){$token_class='Magic'}else {$token_class='Word'}}$t->_new_token($token_class,$word);if ($t->{line_cursor}>= $t->{line_length}){$t->_finalize_token;return 0}$t->_finalize_token->__TOKENIZER__on_char($t)}sub __current_token_is_attribute {my ($t)=@_;my@tokens=$t->_previous_significant_tokens(1);return ($tokens[0]and ($tokens[0]->{_attribute}or $tokens[0]->isa('PPI::Token::Attribute')))}1;
PPI_TOKEN_WORD

$fatpacked{"PPI/Token/_QuoteEngine.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE';
  package PPI::Token::_QuoteEngine;use strict;use Carp ();our$VERSION='1.271';sub __TOKENIZER__on_char {my$class=shift;my$t=$_[0]->{token}? shift : return undef;my$rv=$t->{token}->_fill($t);return undef unless defined$rv;$t->_finalize_token;0}sub _scan_for_unescaped_character {my$class=shift;my$t=shift;my$char=(length $_[0]==1)? quotemeta shift : return undef;my$search=qr/(.*?(?<!\\)(?:\\\\)*$char)/;my$string='';while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};if ($t->{line}=~ m/\G$search/gc){$t->{line_cursor}+= length($1)- 1;return$string .$1}$string .= substr$t->{line},$t->{line_cursor};my$rv=$t->_fill_line('inscan');if ($rv){$t->{line_cursor}=0}elsif (defined$rv){return \$string}else {return undef}}return undef}sub _scan_for_brace_character {my$class=shift;my$t=shift;my$close_brace=$_[0]=~ /^(?:\>|\)|\}|\])$/ ? shift : Carp::confess('');my$open_brace=$close_brace;$open_brace =~ tr/\>\)\}\]/\<\(\{\[/;$close_brace=quotemeta$close_brace;$open_brace=quotemeta$open_brace;my$search=qr/\G(.*?(?<!\\)(?:\\\\)*(?:$open_brace|$close_brace))/;my$string='';my$depth=1;while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};unless ($t->{line}=~ /$search/gc){$string .= substr($t->{line},$t->{line_cursor});my$rv=$t->_fill_line('inscan');if ($rv){$t->{line_cursor}=0;next}if (defined$rv){return \$string}return undef}$string .= $1;$t->{line_cursor}+= length $1;$depth += ($1 =~ /$open_brace$/)? 1 : -1 and next;$t->{line_cursor}-= 1;return$string}\$string}sub _scan_quote_like_operator_gap {my$t=$_[1];my$string='';while (exists$t->{line}){pos$t->{line}=$t->{line_cursor};$t->{line}=~ /\G(\s*(?:\#.*)?)/gc or return undef;$string .= $1;unless ($t->{line_cursor}+ length $1==length$t->{line}){$t->{line_cursor}+= length $1;return$string}my$rv=$t->_fill_line('inscan');if ($rv){$t->{line_cursor}=0}elsif (defined$rv){return \$string}else {return undef}}return undef}1;
PPI_TOKEN__QUOTEENGINE

$fatpacked{"PPI/Token/_QuoteEngine/Full.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE_FULL';
  package PPI::Token::_QuoteEngine::Full;use strict;use Clone ();use Carp ();use PPI::Token::_QuoteEngine ();our$VERSION='1.271';our@ISA='PPI::Token::_QuoteEngine';my%SECTIONS=('('=>{type=>'()',_close=>')' },'<'=>{type=>'<>',_close=>'>' },'['=>{type=>'[]',_close=>']' },'{'=>{type=>'{}',_close=>'}' },);my%QUOTES=('q'=>{operator=>'q',braced=>undef,separator=>undef,_sections=>1 },'qq'=>{operator=>'qq',braced=>undef,separator=>undef,_sections=>1 },'qx'=>{operator=>'qx',braced=>undef,separator=>undef,_sections=>1 },'qw'=>{operator=>'qw',braced=>undef,separator=>undef,_sections=>1 },'qr'=>{operator=>'qr',braced=>undef,separator=>undef,_sections=>1,modifiers=>1 },'m'=>{operator=>'m',braced=>undef,separator=>undef,_sections=>1,modifiers=>1 },'s'=>{operator=>'s',braced=>undef,separator=>undef,_sections=>2,modifiers=>1 },'tr'=>{operator=>'tr',braced=>undef,separator=>undef,_sections=>2,modifiers=>1 },'y'=>{operator=>'y',braced=>undef,separator=>undef,_sections=>2,modifiers=>1 },'/'=>{operator=>undef,braced=>0,separator=>'/',_sections=>1,modifiers=>1 },'<'=>{operator=>undef,braced=>1,separator=>undef,_sections=>1,},'?'=>{operator=>undef,braced=>0,separator=>'?',_sections=>1,modifiers=>1 },);sub new {my$class=shift;my$init=defined $_[0]? shift : Carp::croak("::Full->new called without init string");my$self=PPI::Token::new($class,$init)or return undef;my$options=$QUOTES{$init}or return$self->_error("Unknown quote type '$init'");for (keys %$options){$self->{$_}=$options->{$_}}$self->{modifiers}={}if$self->{modifiers};if ($init eq '<'){$self->{sections}->[0]=Clone::clone($SECTIONS{'<'})}$self}sub _fill {my$class=shift;my$t=shift;my$self=$t->{token}or Carp::croak("::Full->_fill called without current token");if ($self->{operator}){if (substr($t->{line},$t->{line_cursor},1)=~ /\s/){my$gap=$self->_scan_quote_like_operator_gap($t);return undef unless defined$gap;if (ref$gap){$self->{content}.= $$gap;return 0}$self->{content}.= $gap}my$sep=substr($t->{line},$t->{line_cursor}++,1);$self->{content}.= $sep;if (my$section=$SECTIONS{$sep}){$self->{braced}=1;$self->{sections}->[0]=Clone::clone($section)}else {$self->{braced}=0;$self->{separator}=$sep}}my$rv=$self->{braced}? $self->_fill_braced($t): $self->_fill_normal($t);return$rv if!$rv;return 1 unless$self->{modifiers};my$char;my$len=0;while (($char=substr($t->{line},$t->{line_cursor}+ 1,1))=~ /[^\W\d_]/){$len++;$self->{content}.= $char;$self->{modifiers}->{lc$char}=1;$t->{line_cursor}++}}sub _fill_normal {my$self=shift;my$t=shift;my$string=$self->_scan_for_unescaped_character($t,$self->{separator});return undef unless defined$string;if (ref$string){if (length($$string)> 1){my$str=$$string;chop$str;$self->{sections}->[0]={position=>length($self->{content}),size=>length($$string)- 1,type=>"$self->{separator}$self->{separator}",};$self->{_sections}=1}else {$self->{sections}=[];$self->{_sections}=0}$self->{content}.= $$string;return 0}$self->{sections}->[0]={position=>length$self->{content},size=>length($string)- 1,type=>"$self->{separator}$self->{separator}",};$self->{content}.= $string;return 1 if$self->{_sections}==1;$t->{line_cursor}++;$string=$self->_scan_for_unescaped_character($t,$self->{separator});return undef unless defined$string;if (ref$string){if (length($$string)> 1){my$str=$$string;chop$str;$self->{sections}->[1]={position=>length($self->{content}),size=>length($$string)- 1,type=>"$self->{separator}$self->{separator}",}}else {$self->{_sections}=1}$self->{content}.= $$string;return 0}$self->{sections}->[1]={position=>length($self->{content}),size=>length($string)- 1 };$self->{content}.= $string;1}sub _fill_braced {my$self=shift;my$t=shift;my$section=$self->{sections}->[0];my$brace_str=$self->_scan_for_brace_character($t,$section->{_close});return undef unless defined$brace_str;if (ref$brace_str){if (length($$brace_str)> 1){my$str=$$brace_str;chop$str;$self->{sections}->[0]={position=>length($self->{content}),size=>length($$brace_str)- 1,type=>$section->{type},};$self->{_sections}=1}else {$self->{sections}=[];$self->{_sections}=0}$self->{content}.= $$brace_str;return 0}$section->{position}=length$self->{content};$section->{size}=length($brace_str)- 1;$self->{content}.= $brace_str;delete$section->{_close};return 1 if$self->{_sections}==1;my$char=substr($t->{line},++$t->{line_cursor},1);if ($char =~ /\s/){my$gap_str=$self->_scan_quote_like_operator_gap($t);return undef unless defined$gap_str;if (ref$gap_str){$self->{content}.= $$gap_str;return 0}$self->{content}.= $gap_str;$char=substr($t->{line},$t->{line_cursor},1)}$section=$SECTIONS{$char};if ($section){$self->{content}.= $char;$section={%$section };$t->{line_cursor}++;$brace_str=$self->_scan_for_brace_character($t,$section->{_close});return undef unless defined$brace_str;if (ref$brace_str){if (length($$brace_str)> 1){my$str=$$brace_str;chop$str;$self->{sections}->[1]={position=>length($self->{content}),size=>length($$brace_str)- 1,type=>$section->{type},};$self->{_sections}=2}else {$self->{_sections}=1}$self->{content}.= $$brace_str;return 0}else {$self->{sections}->[1]={position=>length($self->{content}),size=>length($brace_str)- 1,type=>$section->{type},};$self->{content}.= $brace_str}}elsif ($char =~ m/ \A [^\w\s] \z /smx){$self->{content}.= $char;$t->{line_cursor}++;my$string=$self->_scan_for_unescaped_character($t,$char);return undef unless defined$string;if (ref$string){if (length($$string)> 1){my$str=$$string;chop$str;$self->{sections}->[1]={position=>length($self->{content}),size=>length($$string)- 1,type=>"$char$char",}}else {$self->{_sections}=1}$self->{content}.= $$string;return 0}$self->{sections}->[1]={position=>length($self->{content}),size=>length($string)- 1,type=>"$char$char",};$self->{content}.= $string}else {$self->{sections}->[1]={position=>length($self->{content}),size=>0,type=>'',};$self->{_error}="No second section of regexp, or does not start with a balanced character";$t->{line_cursor}--;return 0}1}sub _sections {wantarray ? @{$_[0]->{sections}}: scalar @{$_[0]->{sections}}}sub _section_content {my$self=shift;my$i=shift;$self->{sections}or return;my$section=$self->{sections}->[$i]or return;return substr($self->content,$section->{position},$section->{size})}sub _modifiers {my$self=shift;$self->{modifiers}or return;wantarray and return %{$self->{modifiers}};return +{%{$self->{modifiers}}}}sub _delimiters {my$self=shift;$self->{sections}or return;my@delims;for my$sect (@{$self->{sections}}){if (exists$sect->{type}){push@delims,$sect->{type}}else {my$content=$self->content;push@delims,substr($content,$sect->{position}- 1,1).substr($content,$sect->{position}+ $sect->{size},1)}}return@delims}1;
PPI_TOKEN__QUOTEENGINE_FULL

$fatpacked{"PPI/Token/_QuoteEngine/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE_SIMPLE';
  package PPI::Token::_QuoteEngine::Simple;use strict;use PPI::Token::_QuoteEngine ();our$VERSION='1.271';our@ISA='PPI::Token::_QuoteEngine';sub new {my$class=shift;my$separator=shift or return undef;my$self=PPI::Token::new($class,$separator)or return undef;$self->{separator}=$separator;$self}sub _fill {my$class=shift;my$t=shift;my$self=$t->{token}or return undef;my$string=$self->_scan_for_unescaped_character($t,$self->{separator});return undef unless defined$string;if (ref$string){$self->{content}.= $$string;return 0}else {$self->{content}.= $string;return$self}}1;
PPI_TOKEN__QUOTEENGINE_SIMPLE

$fatpacked{"PPI/Tokenizer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKENIZER';
  package PPI::Tokenizer;use strict;use Params::Util qw{_INSTANCE _SCALAR0 _ARRAY0};use List::Util 1.33 ();use PPI::Util ();use PPI::Element ();use PPI::Token ();use PPI::Exception ();use PPI::Exception::ParserRejection ();our$VERSION='1.271';my%X_CAN_FOLLOW_OPERATOR=map {$_=>1}qw(-- ++);my%X_CAN_FOLLOW_STRUCTURE=map {$_=>1}qw(} ] \));my%X_CAN_FOLLOW_WORD=map {$_=>1}qw(endgrent endhostent endnetent endprotoent endpwent endservent fork getgrent gethostent getlogin getnetent getppid getprotoent getpwent getservent setgrent setpwent time times wait wantarray __SUB__);sub new {my$class=ref($_[0])|| $_[0];my$self=bless {source=>undef,source_bytes=>undef,line=>undef,line_length=>undef,line_cursor=>undef,line_count=>0,token=>undef,class=>'PPI::Token::BOM',zone=>'PPI::Token::Whitespace',tokens=>[],token_cursor=>0,token_eof=>0,perl6=>[],},$class;if (!defined $_[1]){PPI::Exception->throw("No source provided to Tokenizer")}elsif (!ref $_[1]){my$source=PPI::Util::_slurp($_[1]);if (ref$source){$self->{source}=$$source}else {return($source)}}elsif (_SCALAR0($_[1])){$self->{source}=${$_[1]}}elsif (_ARRAY0($_[1])){$self->{source}=join '',map {"\n"}@{$_[1]}}else {PPI::Exception->throw(ref($_[1])." is not supported as a source provider")}$self->{source_bytes}=length$self->{source};if ($self->{source_bytes}){$self->{source}=~ s/(?:\015{1,2}\012|\015|\012)/\n/g;$self->{source}=[split /(?<=\n)/,$self->{source}]}else {$self->{source}=[]}if (List::Util::any {/^__(?:DATA|END)__\s*$/}@{$self->{source}}){$self->{source_eof_chop}=''}elsif (!defined$self->{source}->[0]){$self->{source_eof_chop}=''}elsif ($self->{source}->[-1]=~ /\s$/){$self->{source_eof_chop}=''}else {$self->{source_eof_chop}=1;$self->{source}->[-1].= ' '}$self}sub get_token {my$self=shift;if ($self->{token_eof}and $self->{token_cursor}> scalar @{$self->{tokens}}){return 0}if (my$token=$self->{tokens}->[$self->{token_cursor}]){$self->{token_cursor}++;return$token}my$line_rv;my$rv=eval {while ($line_rv=$self->_process_next_line){if (defined(my$token=$self->{tokens}->[$self->{token_cursor}])){$self->{token_cursor}++;return$token}}return undef};if ($@){if (_INSTANCE($@,'PPI::Exception')){$@->throw}else {my$errstr=$@;$errstr =~ s/^(.*) at line .+$/$1/;PPI::Exception->throw($errstr)}}elsif ($rv){return$rv}if (defined$line_rv){if (my$token=$self->{tokens}->[$self->{token_cursor}]){$self->{token_cursor}++;return$token}$self->{token_eof}=1;return 0}undef}sub all_tokens {my$self=shift;my$ok=eval {unless ($self->{token_eof}){my$rv;while ($rv=$self->_process_next_line){}unless (defined$rv){PPI::Exception->throw("Error while processing source")}$self->_clean_eof}1};if (!$ok){my$errstr=$@;$errstr =~ s/^(.*) at line .+$/$1/;PPI::Exception->throw($errstr)}return [@{$self->{tokens}}]}sub increment_cursor {$_[0]->get_token and 1}sub decrement_cursor {my$self=shift;return 0 unless$self->{token_cursor};$self->{token_eof}=0;--$self->{token_cursor}}sub _get_line {my$self=shift;return undef unless$self->{source};my$line=shift @{$self->{source}};$self->{source}=undef unless defined$line;return$line}sub _fill_line {my$self=shift;my$inscan=shift;my$line=$self->_get_line;unless (defined$line){unless ($inscan){delete$self->{line};delete$self->{line_cursor};delete$self->{line_length};return 0}$self->{line_cursor}=$self->{line_length};return 0}$self->{line}=$line;$self->{line_cursor}=-1;$self->{line_length}=length$line;$self->{line_count}++;1}sub _char {my$self=shift;substr($self->{line},$self->{line_cursor},1)}sub _process_next_line {my$self=shift;my$rv;unless ($rv=$self->_fill_line){return undef unless defined$rv;$self->_finalize_token;return 0}$rv=$self->{class}->__TOKENIZER__on_line_start($self);unless ($rv){if (ref$self->{source}eq 'ARRAY' and!@{$self->{source}}){$self->_clean_eof}return 1 if defined$rv;PPI::Exception->throw("Error at line $self->{line_count}")}while ($rv=$self->_process_next_char){}unless (defined$rv){PPI::Exception->throw("Error at line $self->{line_count}, character $self->{line_cursor}")}$self->{class}->__TOKENIZER__on_line_end($self);unless (ref($self->{source})eq 'ARRAY' and @{$self->{source}}){return$self->_clean_eof}return 1}sub _process_next_char {my$self=shift;if (!defined$self->{line_cursor}or!defined$self->{line_length}){return undef}return 0 if ++$self->{line_cursor}>= $self->{line_length};my$result;unless ($result=$self->{class}->__TOKENIZER__on_char($self)){return defined$result ? 1 : undef}my$char=substr($self->{line},$self->{line_cursor},1);if ($result eq '1'){if (defined$self->{token}){$self->{token}->{content}.= $char}else {defined($self->{token}=$self->{class}->new($char))or return undef}return 1}if ($self->{class}ne "PPI::Token::$result"){$self->_new_token($result,$char)}elsif (defined$self->{token}){$self->{token}->{content}.= $char}else {defined($self->{token}=$self->{class}->new($char))or return undef}1}sub _finalize_token {my$self=shift;return$self->{class}unless defined$self->{token};push @{$self->{tokens}},$self->{token};$self->{token}=undef;$self->{class}=$self->{zone}}sub _new_token {my$self=shift;my$class=substr($_[0],0,12)eq 'PPI::Token::' ? shift : 'PPI::Token::' .shift;$self->_finalize_token if defined$self->{token};defined($self->{token}=$class->new($_[0]))or PPI::Exception->throw;$self->{class}=$class;1}sub _clean_eof {my$self=shift;$self->_finalize_token if$self->{token};my$last_token=$self->{tokens}->[-1 ];unless (length$last_token->{content}){pop @{$self->{tokens}}}if ($self->{source_eof_chop}){$last_token=$self->{tokens}->[-1 ];$last_token->{content}=~ s/ $//;unless (length$last_token->{content}){pop @{$self->{tokens}}}$self->{source_eof_chop}=''}1}sub _last_token {$_[0]->{tokens}->[-1]}sub _last_significant_token {my$self=shift;my$cursor=$#{$self->{tokens}};while ($cursor >= 0){my$token=$self->{tokens}->[$cursor--];return$token if$token->significant}return}sub _previous_significant_tokens {my$self=shift;my$count=shift || 1;my$cursor=$#{$self->{tokens}};my@tokens;while ($cursor >= 0){my$token=$self->{tokens}->[$cursor--];next if not $token->significant;push@tokens,$token;last if@tokens >= $count}return@tokens}my%OBVIOUS_CLASS=('PPI::Token::Symbol'=>'operator','PPI::Token::Magic'=>'operator','PPI::Token::Number'=>'operator','PPI::Token::ArrayIndex'=>'operator','PPI::Token::Quote::Double'=>'operator','PPI::Token::Quote::Interpolate'=>'operator','PPI::Token::Quote::Literal'=>'operator','PPI::Token::Quote::Single'=>'operator','PPI::Token::QuoteLike::Backtick'=>'operator','PPI::Token::QuoteLike::Command'=>'operator','PPI::Token::QuoteLike::Readline'=>'operator','PPI::Token::QuoteLike::Regexp'=>'operator','PPI::Token::QuoteLike::Words'=>'operator',);my%OBVIOUS_CONTENT=('('=>'operand','{'=>'operand','['=>'operand',';'=>'operand','}'=>'operator',);my%USUALLY_FORCES=map {$_=>1}qw(sub package use no);sub _opcontext {my$self=shift;my@tokens=$self->_previous_significant_tokens(1);my$p0=$tokens[0];return '' if not $p0;my$c0=ref$p0;return$OBVIOUS_CLASS{$c0}if defined$OBVIOUS_CLASS{$c0};return$OBVIOUS_CONTENT{$p0}if defined$OBVIOUS_CONTENT{$p0};return 'operand' if$p0->isa('PPI::Token::Operator');return 'operand' if$p0->content eq '';return ''}sub _current_x_is_operator {my ($self)=@_;return if!@{$self->{tokens}};my ($prev,$prevprev)=$self->_previous_significant_tokens(2);return if!$prev;return!$self->__current_token_is_forced_word if$prev->isa('PPI::Token::Word');return (!$prev->isa('PPI::Token::Operator')|| $X_CAN_FOLLOW_OPERATOR{$prev})&& (!$prev->isa('PPI::Token::Structure')|| $X_CAN_FOLLOW_STRUCTURE{$prev})&&!$prev->isa('PPI::Token::Label')}sub __current_token_is_forced_word {my ($t,$word)=@_;my ($prev,$prevprev)=$t->_previous_significant_tokens(2);if (!$prev){pos$t->{line}=$t->{line_cursor}}else {my$content=$prev->{content};return 1 if$content eq '->';pos$t->{line}=$t->{line_cursor};return 1 if$content eq '{' and $t->{line}=~ /\G\s*\}/gc;if($USUALLY_FORCES{$content}){return if defined$word and $word =~ /^v[0-9]+$/ and ($content eq "use" or $content eq "no");return 1 if not $prevprev;return 1 if not $USUALLY_FORCES{$prevprev->content}and $prevprev->content ne '->';return}}return 1 if$t->{line}=~ /\G\s*=>/gc;return ''}1;
PPI_TOKENIZER

$fatpacked{"PPI/Transform.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TRANSFORM';
  package PPI::Transform;use strict;use Carp ();use List::Util ();use PPI::Document ();use Params::Util qw{_INSTANCE _CLASS _CODE _SCALAR0};our$VERSION='1.271';my%HANDLER;my@ORDER;sub register_apply_handler {my$class=shift;my$handler=_CLASS(shift)or Carp::croak("Invalid PPI::Transform->register_apply_handler param");my$get=_CODE(shift)or Carp::croak("Invalid PPI::Transform->register_apply_handler param");my$set=_CODE(shift)or Carp::croak("Invalid PPI::Transform->register_apply_handler param");if ($HANDLER{$handler}){Carp::croak("PPI::Transform->apply handler '$handler' already exists")}$HANDLER{$handler}=[$get,$set ];unshift@ORDER,$handler}__PACKAGE__->register_apply_handler('SCALAR',\&_SCALAR_get,\&_SCALAR_set);__PACKAGE__->register_apply_handler('PPI::Document',sub {$_[0]},sub() {1});sub new {my$class=shift;bless {@_ },$class}sub document {my$class=shift;die "$class does not implement the required ->document method"}sub apply {my$self=_SELF(shift);my$it=defined $_[0]? shift : return undef;my$class=_SCALAR0($it)? 'SCALAR' : List::Util::first {_INSTANCE($it,$_)}@ORDER or return undef;my$handler=$HANDLER{$class}or die("->apply handler for $class missing! Panic");my$Document=_INSTANCE($handler->[0]->($it),'PPI::Document')or Carp::croak("->apply handler for $class failed to get a PPI::Document");$self->document($Document)or return undef;$handler->[1]->($it,$Document)or Carp::croak("->apply handler for $class failed to save the changed document");1}sub file {my$self=_SELF(shift);my$input=defined $_[0]? shift : return undef;my$output=@_ ? defined $_[0]? "$_[0]" : undef : $input or return undef;my$Document=PPI::Document->new("$input")or return undef;$self->document($Document)or return undef;$Document->save($output)}sub _SCALAR_get {PPI::Document->new($_[0])}sub _SCALAR_set {my$it=shift;$$it=$_[0]->serialize;1}sub _SELF {return shift if ref $_[0];my$self=$_[0]->new or Carp::croak("Failed to auto-instantiate new $_[0] object");$self}1;
PPI_TRANSFORM

$fatpacked{"PPI/Transform/UpdateCopyright.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TRANSFORM_UPDATECOPYRIGHT';
  package PPI::Transform::UpdateCopyright;use strict;use Params::Util qw{_STRING};use PPI::Transform ();our$VERSION='1.271';sub new {my$self=shift->SUPER::new(@_);unless (defined _STRING($self->name)){PPI::Exception->throw("Did not provide a valid name param")}return$self}sub name {$_[0]->{name}}sub document {my$self=shift;my$document=_INSTANCE(shift,'PPI::Document')or return undef;my$name=quotemeta$self->name;my$regexp=qr/\bcopyright\b.*$name/m;my$elements=$document->find(sub {$_[1]->isa('PPI::Token::Pod')or return '';$_[1]->content =~ $regexp or return '';return 1});return undef unless defined$elements;return 0 unless$elements;my$changes=0;my$change=sub {my$copyright=shift;my$thisyear=(localtime time)[5]+ 1900;my@year=$copyright =~ m/(\d{4})/g;if (@year==1){if ($year[0]==$thisyear){return$copyright}else {$changes++;$copyright =~ s/(\d{4})/$1 - $thisyear/;return$copyright}}if (@year==2){if ($year[1]==$thisyear){return$copyright}else {$changes++;$copyright =~ s/$year[1]/$thisyear/;return$copyright}}die "Invalid or unknown copyright line '$copyright'"};my$pattern=qr/\b(copyright.*\d)({4}(?:\s*-\s*\d{4})?)(.*$name)/mi;for my$element (@$elements){$element =~ s/$pattern/$1 . $change->($2) . $2/eg}return$changes}1;
PPI_TRANSFORM_UPDATECOPYRIGHT

$fatpacked{"PPI/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_UTIL';
  package PPI::Util;use strict;use Exporter ();use Digest::MD5 ();use Params::Util qw{_INSTANCE _SCALAR0 _ARRAY0};our$VERSION='1.271';our@ISA='Exporter';our@EXPORT_OK=qw{_Document _slurp};use constant HAVE_UNICODE=>!!($] >= 5.008007);sub TRUE () {1}sub FALSE () {''}sub _Document {shift if @_ > 1;return undef unless defined $_[0];require PPI::Document;return PPI::Document->new(shift)unless ref $_[0];return PPI::Document->new(shift)if _SCALAR0($_[0]);return PPI::Document->new(shift)if _ARRAY0($_[0]);return shift if _INSTANCE($_[0],'PPI::Document');return undef}sub _slurp {my$file=shift;local $/=undef;local*FILE;open(FILE,'<',$file)or return "open($file) failed: $!";my$source=<FILE>;close(FILE)or return "close($file) failed: $!";return \$source}sub md5hex {my$string=shift;$string =~ s/(?:\015{1,2}\012|\015|\012)/\015/gs;Digest::MD5::md5_hex($string)}sub md5hex_file {my$file=shift;my$content=_slurp($file);return undef unless ref$content;$$content =~ s/(?:\015{1,2}\012|\015|\012)/\n/gs;md5hex($$content)}1;
PPI_UTIL

$fatpacked{"PPI/XSAccessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_XSACCESSOR';
  package PPI::XSAccessor;use 5.006;use strict;use PPI ();our$VERSION='1.271';package PPI::Document;use Class::XSAccessor replace=>1,getters=>{readonly=>'readonly',},true=>['scope' ];package PPI::Document::File;use Class::XSAccessor replace=>1,getters=>{filename=>'filename',};package PPI::Document::Fragment;use Class::XSAccessor replace=>1,false=>['scope',];package PPI::Document::Normalized;use Class::XSAccessor replace=>1,getters=>{'_Document'=>'Document','version'=>'version','functions'=>'functions',};package PPI::Element;use Class::XSAccessor replace=>1,true=>['significant',];package PPI::Exception;use Class::XSAccessor replace=>1,getters=>{message=>'message',};package PPI::Node;use Class::XSAccessor replace=>1,false=>['scope',];package PPI::Normal;use Class::XSAccessor replace=>1,getters=>{'layer'=>'layer',};package PPI::Statement;use Class::XSAccessor replace=>1,true=>['__LEXER__normal',];package PPI::Statement::Compound;use Class::XSAccessor replace=>1,true=>['scope',],false=>['__LEXER__normal',];package PPI::Statement::Data;use Class::XSAccessor replace=>1,false=>['_complete',];package PPI::Statement::End;use Class::XSAccessor replace=>1,true=>['_complete',];package PPI::Statement::Given;use Class::XSAccessor replace=>1,true=>['scope',],false=>['__LEXER__normal',];package PPI::Token;use Class::XSAccessor replace=>1,getters=>{content=>'content',},setters=>{set_content=>'content',},true=>['__TOKENIZER__on_line_start','__TOKENIZER__on_line_end',];1;
PPI_XSACCESSOR

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;

use App::perlimports::CLI ();

App::perlimports::CLI->new->run;
exit(0);

# PODNAME: perlimports
# ABSTRACT: A command line utility for cleaning up imports in your Perl code

=pod

=head1 SYNOPSIS

Update a file in place. (Make sure you can revert the file if you need to.)

    perlimports --filename test-data/foo.pl --inplace-edit

If some of your imported modules are in local directories, you can give some
hints as to where to find them:

    perlimports --filename test-data/foo.pl --inplace-edit --libs t/lib,/some/dir/lib

Redirect output to a new file:

    perlimports --filename test-data/foo.pl > foo.new.pl

Process all test files:

    find t -type f | grep .t$ | xargs -L 1 perlimports --libs lib,t/lib -i --ignore-modules Test::More --no-preserve-unused --no-preserve-duplicates --log-level notice -f

The above command finds all test files in C<./t> and pipes them to
C<perlimports>. C<lib> and C<t/lib> have been added to C<@INC>. The files are
edited in place (C<-i>). Verbose errors will be displayed and the L<Test::More>
module is ignored.

Process all lib files:

    find lib -type f | grep .pm$ | xargs -n 1 perlimports -i --libs lib --no-preserve-unused --no-preserve-duplicates -f

The above command finds all C<.pm> files in C<./lib> and pipes them to
C<perlimports>. C<lib> has been added to C<@INC>. The files are edited in place
(C<-i>).

=head1 COMMAND LINE PARAMETERS

=head2 --filename|-f

The absolute or relative path to a file to process.

    --filename path/to/file

    -f path/to/file

=head2 --ignore-modules

A comma-separated list of module names which should be ignored by this script.
Any modules in this list should remain unchanged after processing.

    --ignore-modules Foo,Foo::Bar

=head2 --ignore-modules-filename

The absolute or relative path to a file which contains a lost of module names
to ignore. (See above for behaviour). The pattern is one module name per line.

    Foo
    Foo::Bar

=head2 --ignore-modules-pattern

A regular expression to match module names which should be ignored by this
script. Any modules matched by this regular expression remain unchanged after
processing.

    --ignore-modules-pattern '^(Foo|Foo::Bar)'

=head2 --ignore-modules-pattern-filename

The absolute or relative path to a file which contains a list of regular
expression that matches modules that should be ignored. (See above for behaviour).
The pattern is one regular expression per line.

    ^Foo
    ^Foo::Bar

=head2 --never-export-modules

A comma-separated list of module names which should never export symbols. If
these modules are found, we will ensure that they have an empty import list.
So, C<use Foo;> becomes C<use Foo ();>.

    --never-export-modules Foo,Foo::Bar

=head2 --never-export-modules-filename

The absolute or relative path to a file which contains a lost of module names
which should never export symbols. (See above for behaviour). The pattern is
one module name per line.

    Foo
    Foo::Bar

=head2 --inplace-edit|-i

Edit the file in place rather than printing the result to STDOUT. Make sure you
have a backup copy first.

    --inplace--edit
    -i

Edit the file in place rather than printing the result to STDOUT. Make sure you
have a backup copy first.

=head2 --[no-]padding

C<--padding> is enabled by default, so you only need to pass this arg if you
want to be explicit. This setting adds whitespace inside the parentheses.

    # --padding
    use Foo qw( bar baz );

The C<--no-padding> arg allows you to disable the additional padding inside
parentheses.

    # --no-padding
    use Foo qw(bar baz);

=head2 --libs

A comma separated list of module directories which are not in your C<@INC>

    --libs lib,t/lib

=head2 --[no-]preserve-duplicates

When enabled, only one use statement per module will be preserved. Defaults to
preserving duplicate statements.

For example, when enabled the following text

    use Foo qw( bar );
    use Foo qw (baz );

will be converted to:

    use Foo qw( bar baz );

If left disabled, the above will probably be converted to:

    use Foo qw( bar baz );
    use Foo qw( bar baz );

This allows you to determine manually how you'd like to handle the imports in
question. Use this setting with care.

=head2 --[no-]preserve-unused

When enabled, unused modules will be removed. Defaults to preserving unused
modules.

Enabling this may remove modules which are only present for the purposes of
preloading or which aren't being detected for other reasons, so use this
setting with care.

=head2 --read-stdin

Read statements to process from STDIN rather than processing the entire file.
This is intended for use by editors, like C<vim>. See the C<vim> heading below
for more information on how to set up an integration with your editor.

If this option is enabled, then C<--inplace-edit|-i> is not available.

    --read-stdin

=head2 --log-level|-l

Generally only useful for debugging. C<notice> notifies about progress, like
which file or snippet is currently being processed. C<info> will generally log
the errors which were swallowed as text was being processed. All levels are
subject to change.

    --log-level notice
    --log-level info
    -l notice
    -l info

See L<https://metacpan.org/pod/Log::Dispatch#LOG-LEVELS> for a list of
available log levels. Log output defaults to STDERR. See C<--log-filename> if
you'd rather log to a file.

=head2 --log-filename

Name of a file to redirect logs to, rather than STDERR.

=head2 --help

Output a concise help menu, with a summary of available parameters.

    --help

=head2 --verbose-help

Include the SYNOPSIS section from this page after printing the C<--help> menu
listed above.

=head2 VIM

If you're a C<vim> user, you can pipe your import statements to perlimports directly.

    :vnoremap <silent> im :!perlimports --read-stdin --filename '%:p'<CR>

The above statement will allow you to visually select one or more lines of code
and have them updated in place by C<perlimports>. Once you have selected the
code enter C<im> to have your imports (re)formatted.
